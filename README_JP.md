# Gemini CLI ヒント & テクニック

**このガイドは、Gemini CLIをエージェンティック・コーディングに効果的に活用するための約30のプロ向けヒントを網羅しています**

**[Gemini CLI](https://github.com/google-gemini/gemini-cli)** は、GoogleのGeminiモデルの能力をあなたの[ターミナル](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=The%20Gemini%20CLI%20is%20an,via%20a%20Gemini%20API%20key)に直接もたらすオープンソースのAIアシスタントです。これは会話型で「エージェンティック（自律的）」なコマンドラインツールとして機能します。つまり、あなたのリクエストを推論し、（シェルコマンドの実行やファイルの編集などの）ツールを選択し、開発[ワークフロー](https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-deep-dive-into-gemini-cli-with-taylor-mullen#:~:text=The%20Gemini%20CLI%20%20is,understanding%20of%20the%20developer%20workflow)を支援するためにマルチステップの計画を実行することができます。

実用的には、Gemini CLIは超強力なペアプログラマー兼コマンドラインアシスタントのように振る舞います。コーディングタスク、デバッグ、コンテンツ生成、さらにはシステム自動化まで、すべて自然言語のプロンプトを通じて行うことに優れています。プロ向けのヒントに入る前に、Gemini CLIのセットアップ方法と実行方法を簡単におさらいしましょう。

## 目次

- [はじめに](#はじめに)
- [ヒント 1: `GEMINI.md` を使用してコンテキストを持続させる](#ヒント-1-geminimd-を使用してコンテキストを持続させる)
- [ヒント 2: カスタムスラッシュコマンドを作成する](#ヒント-2-カスタムスラッシュコマンドを作成する)
- [ヒント 3: 独自の `MCP` サーバーでGeminiを拡張する](#ヒント-3-独自の-mcp-サーバーでgeminiを拡張する)
- [ヒント 4: メモリの追加と呼び出しを活用する](#ヒント-4-メモリの追加と呼び出しを活用する)
- [ヒント 5: チェックポイントと `/restore` を元に戻すボタンとして使用する](#ヒント-5-チェックポイントと-restore-を元に戻すボタンとして使用する)
- [ヒント 6: Google Docs、Sheetsなどを読み込む](#ヒント-6-google-docs-sheetsなどを読み込む)
- [ヒント 7: 明示的なコンテキストのために `@` でファイルや画像を参照する](#ヒント-7-明示的なコンテキストのために--でファイルや画像を参照する)
- [ヒント 8: その場でのツール作成（Geminiにヘルパーを作らせる）](#ヒント-8-その場でのツール作成geminiにヘルパーを作らせる)
- [ヒント 9: システムのトラブルシューティングと構成にGemini CLIを使用する](#ヒント-9-システムのトラブルシューティングと構成にgemini-cliを使用する)
- [ヒント 10: YOLOモード - ツールアクションの自動承認（注意して使用）](#ヒント-10-yoloモード---ツールアクションの自動承認注意して使用)
- [ヒント 11: ヘッドレス＆スクリプティングモード（Gemini CLIをバックグラウンドで実行）](#ヒント-11-ヘッドレススクリプティングモードgemini-cliをバックグラウンドで実行)
- [ヒント 12: チャットセッションの保存と再開](#ヒント-12-チャットセッションの保存と再開)
- [ヒント 13: マルチディレクトリワークスペース - 1つのGemini、多数のフォルダ](#ヒント-13-マルチディレクトリワークスペース---1つのgemini多数のフォルダ)
- [ヒント 14: AIアシスタンスでファイルを整理・クリーンアップする](#ヒント-14-aiアシスタンスでファイルを整理クリーンアップする)
- [ヒント 15: 長い会話を圧縮してコンテキスト内に収める](#ヒント-15-長い会話を圧縮してコンテキスト内に収める)
- [ヒント 16: `!` でシェルコマンドをパススルー（ターミナルと話す）](#ヒント-16--でシェルコマンドをパススルーターミナルと話す)
- [ヒント 17: すべてのCLIツールを潜在的なGeminiツールとして扱う](#ヒント-17-すべてのcliツールを潜在的なgeminiツールとして扱う)
- [ヒント 18: マルチモーダルAIを活用する - Geminiに画像などを見せる](#ヒント-18-マルチモーダルaiを活用する---geminiに画像などを見せる)
- [ヒント 19: 安定性のために `$PATH`（およびツールの可用性）をカスタマイズする](#ヒント-19-安定性のために-pathおよびツールの可用性をカスタマイズする)
- [ヒント 20: トークンキャッシュと統計でトークン消費を追跡・削減する](#ヒント-20-トークンキャッシュと統計でトークン消費を追跡削減する)
- [ヒント 21: 素早いクリップボードコピーに `/copy` を使用する](#ヒント-21-素早いクリップボードコピーに-copy-を使用する)
- [ヒント 22: シェルモードと終了のために `Ctrl+C` をマスターする](#ヒント-22-シェルモードと終了のために-ctrlc-をマスターする)
- [ヒント 23: `settings.json` でGemini CLIをカスタマイズする](#ヒント-23-settingsjson-でgemini-cliをカスタマイズする)
- [ヒント 24: コンテキストとDiffのためにIDE統合（VS Code）を活用する](#ヒント-24-コンテキストとdiffのためにide統合vs-codeを活用する)
- [ヒント 25: `Gemini CLI GitHub Action` でリポジトリタスクを自動化する](#ヒント-25-gemini-cli-github-action-でリポジトリタスクを自動化する)
- [ヒント 26: 洞察と可観測性のためにテレメトリを有効にする](#ヒント-26-洞察と可観測性のためにテレメトリを有効にする)
- [ヒント 27: ロードマップに注目する（バックグラウンドエージェントなど）](#ヒント-27-ロードマップに注目するバックグラウンドエージェントなど)
- [ヒント 28: `Extensions` でGemini CLIを拡張する](#ヒント-28-extensions-でgemini-cliを拡張する)
- [ヒント 29: コーギーモードのイースターエッグ 🐕](#ヒント-29-コーギーモードのイースターエッグ-)

## はじめに

**インストール:** npm経由でGemini CLIをインストールできます。グローバルインストールの場合は以下を使用します：

```bash
npm install -g @google/gemini-cli
```

または、`npx`を使用してインストールせずに実行します：

```bash
npx @google/gemini-cli
```

Gemini CLIはすべての主要なプラットフォームで利用可能です（Node.js/TypeScriptで構築されています）。インストール後、ターミナルで `gemini` コマンドを実行するだけで、インタラクティブな[CLI](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Interactive%20Mode%20,conversational%20session)セッションが起動します。

**認証:** 最初に使用する際、Geminiサービスでの認証が必要です。2つのオプションがあります： (1) **Googleアカウントログイン（無料枠）** - これにより、十分な利用制限（1分あたり約60リクエスト、1[日](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Unmatched%20usage%20limits%20for%20individual,developers)あたり1,000リクエスト）でGemini 2.5 Proを無料で使用できます。起動時、Gemini CLIはGoogleアカウントでのサインインを求めます（請求情報は[不要](https://genmind.ch/posts/Howto-Supercharge-Your-Terminal-with-Gemini-CLI/#:~:text=%2A%20Google,Google%20AI%20Studio%2C%20then%20run)です）。 (2) **APIキー（有料または上位ティアアクセス）** - Google AI [Studio](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=1,key%20from%20Google%20AI%20Studio)からAPIキーを取得し、環境変数 `GEMINI_API_KEY` を設定して[使用](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Method%201%3A%20Shell%20Environment%20Variable,zshrc)できます。

APIキーの使用は、より高いクォータとエンタープライズデータの保護を提供する場合があります。有料/請求ありの使用ではプロンプトはトレーニングに使用されませんが、ログは[安全性](https://genmind.ch/posts/Howto-Supercharge-Your-Terminal-with-Gemini-CLI/#:~:text=responses%20may%20be%20logged%20for,Google%20AI%20Studio%2C%20then%20run)のために保持される場合があります。

例えば、シェルプロファイルに以下を追加します：

```bash
export GEMINI_API_KEY="YOUR_KEY_HERE"
```

**基本的な使用法:** インタラクティブセッションを開始するには、引数なしで `gemini` を実行します。`gemini>` プロンプトが表示され、リクエストやコマンドを入力できます。例えば：

```bash
$ gemini
gemini> SQLiteを使用したReactのレシピ管理アプリを作成して
```

その後、Gemini CLIがファイルを作成し、依存関係をインストールし、テストを実行するなどしてリクエストを満たす様子を見ることができます。ワンショット呼び出し（非インタラクティブ）を好む場合は、プロンプトと共に `-p` フラグを使用します。例えば：

```bash
gemini -p "添付ファイルの要点を要約して。 @./report.txt"
```

これは単一の応答を出力して[終了](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=gemini)します。また、Gemini CLIに入力をパイプすることもできます：例えば、 `echo "Count to 10" | gemini` は[stdin](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=gemini%20,txt)経由でプロンプトを供給します。

**CLIインターフェース:** Gemini CLIはリッチなREPLライクなインターフェースを提供します。セッション、ツール、設定を制御するための**スラッシュコマンド**（`/`で始まる特別なコマンド）と、シェルコマンドを直接実行するための**バンコマンド**（`!`で始まる）をサポートしています。これらについては以下のプロのヒントで詳しく説明します。デフォルトでは、Gemini CLIはセーフモードで動作し、システムを変更するアクション（ファイルの書き込み、シェルコマンドの実行など）は確認を求めます。ツールアクションが提案されると、差分やコマンドが表示され、承認するか拒否するかを尋ねられます（`Y/n`）。これにより、AIが同意なしに望まない変更を行うことを防ぎます。

基本を理解したところで、Gemini CLIを最大限に活用するためのプロのヒントと隠れた機能を見ていきましょう。各ヒントは最初に簡単な例を示し、その後に詳細とニュアンスを説明します。これらのヒントは、ツールの作成者（例：Taylor Mullen）やGoogle Developer Relationsチーム、そしてコミュニティからのアドバイスと洞察を取り入れ、Gemini CLIの**パワーユーザーのための決定版ガイド**として機能します。

## ヒント 1: `GEMINI.md` を使用してコンテキストを持続させる

**クイックユースケース:** プロンプトで同じことを繰り返すのをやめましょう。`GEMINI.md` ファイルを作成してプロジェクト固有のコンテキストや指示を提供することで、AIが毎回言われなくても重要な背景知識を常に保持できるように[します](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Context%20Files%20%28)。

プロジェクトに取り組む際、コーディングスタイルのガイドライン、プロジェクトアーキテクチャ、重要な事実など、AIに覚えておいてほしい全体的な詳細がよくあります。Gemini CLIでは、これらを1つ以上の `GEMINI.md` ファイルにエンコードできます。プロジェクトに `.gemini` フォルダを作成し（まだ存在しない場合）、`GEMINI.md` という名前のMarkdownファイルを追加して、AIに保持させたいメモや指示を記述します。例えば：

```markdown
# Project Phoenix - AI Assistant

- すべてのPythonコードはPEP 8スタイルに従うこと。
- インデントにはスペース4つを使用すること。
- ユーザーはデータパイプラインを構築している；関数型プログラミングのパラダイムを優先すること。
```

このファイルをプロジェクトルート（またはより細かいコンテキストのためのサブディレクトリ）に配置します。これで、そのプロジェクトで `gemini` を実行するといつでも、これらの指示が自動的に[コンテキスト](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Context%20Files%20%28)に読み込まれます。つまり、モデルは*常に*これらを前提として動作するため、すべてのプロンプトに同じガイダンスを前置きする必要がなくなります。

**仕組み:** Gemini CLIは階層的なコンテキスト読み込み[システム](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Hierarchical%20Loading%3A%20The%20CLI%20combines,The%20loading%20order%20is)を使用します。**グローバルコンテキスト**（`~/.gemini/GEMINI.md`、プロジェクト間のデフォルトに使用可能）と**プロジェクト固有の `GEMINI.md`**、さらにはサブフォルダ内のコンテキストファイルを組み合わせます。より具体的なファイルが一般的なファイルをオーバーライドします。いつでも以下のコマンドを使用して、どのコンテキストが読み込まれたかを確認できます：

```bash
/memory show
```

これにより、AIが[見ている](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,current%20conversation%20with%20a%20tag)結合された完全なコンテキストが表示されます。`GEMINI.md` に変更を加えた場合は、[セッション](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,current%20conversation%20with%20a%20tag)を再起動せずにコンテキストをリロードするために `/memory refresh` を使用してください。

**プロのヒント:** `/init` スラッシュコマンドを使用して、スターター `GEMINI.md` を素早く生成します。新しいプロジェクトで `/init` を実行すると、検出された技術スタック、プロジェクトの概要などの情報を含むテンプレートコンテキストファイルが作成[されます](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,directory%20workspace%20%28e.g.%2C%20%60add).。その後、そのファイルを編集して拡張できます。大規模なプロジェクトの場合、コンテキストを複数のファイルに分割し、`@include` 構文を使用して `GEMINI.md` に**インポート**することを検討してください。例えば、メインの `GEMINI.md` に `@./docs/prompt-guidelines.md` のような行を入れて、追加のコンテキスト[ファイル](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Modularizing%20Context%20with%20Imports%3A%20You,files)を取り込むことができます。これにより、指示が整理されます。

適切に作成された `GEMINI.md` があれば、基本的にGemini CLIにプロジェクトの要件や慣習の「記憶」を与えることができます。この**持続的なコンテキスト**は、より関連性の高い応答と、プロンプトエンジニアリングの試行錯誤の削減につながります。

## ヒント 2: カスタムスラッシュコマンドを作成する

**クイックユースケース:** 独自のスラッシュコマンドを定義して、反復タスクをスピードアップします。例えば、説明からユニットテストを生成する `/test:gen` コマンドや、テストデータベースをドロップして再作成する `/db:reset` コマンドを作成できます。これは、ワークフローに合わせたワンライナーでGemini CLIの機能を拡張します。

Gemini CLIは、シンプルな設定ファイルで定義できる**カスタムスラッシュコマンド**をサポートしています。内部的には、これらは基本的に事前定義されたプロンプトテンプレートです。作成するには、グローバルコマンド用の `~/.gemini/` またはプロジェクト固有の[コマンド](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Custom%20Commands)用の `.gemini/` フォルダの下に `commands/` ディレクトリを作成します。`commands/` 内に、新しいコマンドごとにTOMLファイルを作成します。ファイル名の形式がコマンド名を決定します。例えば、`test/gen.toml` というファイルは `/test:gen` というコマンドを定義します。

例を見てみましょう。要件の説明からユニットテストを生成するコマンドが必要だとします。以下の内容で `~/.gemini/commands/test/gen.toml` を作成できます：

```toml
# 呼び出し方法: /test:gen "テストの説明"
description = "要件に基づいてユニットテストを生成します。"
prompt = """
あなたはエキスパートのテストエンジニアです。以下の要件に基づいて、Jestフレームワークを使用した包括的なユニットテストを作成してください。

要件: {{args}}
"""
```

これで、Gemini CLIをリロードまたは再起動した後、以下のように入力するだけです：

```bash
/test:gen "ログインボタンが成功時にダッシュボードにリダイレクトすることを確認する"
```

Gemini CLIは `/test:gen` を認識し、プロンプトテンプレート内の `{{args}}` を提供された引数（この場合は要件）に置き換えます。その後、AIは[それに応じて](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Example%3A%20%60)Jestユニットテストの生成を進めます。`description` フィールドはオプションですが、`/help` や `/tools` を実行して利用可能なコマンドを一覧表示する際に使用されます。

このメカニズムは非常に強力です。実質的に、自然言語でAIをスクリプト化できます。コミュニティは多数の便利なカスタムコマンドを作成しています。例えば、GoogleのDevRelチームは、APIドキュメントの作成、データのクリーニング、ボイラープレート[コード](https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-deep-dive-into-gemini-cli-with-taylor-mullen#:~:text=,to%20generate%20a%20better%20output)のセットアップなどの一般的なフローをスクリプト化する方法を示す*10の実用的なワークフローコマンド*のセット（オープンソースリポジトリ経由）を共有しました。カスタムコマンドを定義することで、複雑なプロンプト（または一連のプロンプト）を再利用可能なショートカットにパッケージ化できます。

**プロのヒント:** カスタムコマンドは、フォーマットを強制したり、特定のタスクに対してAIに「ペルソナ」を適用したりするためにも使用できます。例えば、脆弱性のコードレビューを行うために、常に「あなたはセキュリティ監査人です...」という前置きをする `/review:security` コマンドを持つことができます。このアプローチにより、特定のカテゴリのタスクに対するAIの応答の一貫性が確保されます。

チームとコマンドを共有するには、プロジェクトのリポジトリ（`.gemini/commands` ディレクトリ下）にTOMLファイルをコミットできます。Gemini CLIを持っているチームメンバーは、プロジェクトで作業する際にそれらのコマンドを自動的に取得します。これは、チーム全体で**AI支援ワークフローを標準化**するための素晴らしい方法です。

## ヒント 3: 独自の `MCP` サーバーでGeminiを拡張する

**クイックユースケース:** Geminiを外部システムや組み込まれていないカスタムツールと連携させたいとします。例えば、独自のデータベースをクエリしたり、Figmaのデザインと統合したりする場合です。これは、カスタムの**Model Context Protocol (MCP) サーバー**を実行し、それをGemini [CLI](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Extend%20the%20CLI%20with%20your,add%7Clist%7Cremove%3E%60%20commands)にプラグインすることで実現できます。MCPサーバーを使用すると、新しいツールや機能をGeminiに追加でき、実質的に**エージェントを拡張**できます。

Gemini CLIには、いくつかのMCPサーバーが標準で付属しています（たとえば、Google検索、コード実行サンドボックスなどを可能にするもの）。そして、独自のサーバーを追加することもできます。MCPサーバーは基本的に、Geminiのタスクを処理するためのシンプルなプロトコルを話す外部プロセス（ローカルスクリプト、マイクロサービス、またはクラウドエンドポイント）です。このアーキテクチャがGemini CLIを非常に[拡張性](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts)の高いものにしています。

**MCPサーバーの例:** コミュニティやGoogleが提供するMCP統合には、**Figma MCP**（Figmaからデザインの詳細を取得）、**Clipboard MCP**（システムクリップボードの読み書き）、その他が含まれます。実際、内部デモでGemini CLIチームは、コンテンツをGoogle [Docs](https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-deep-dive-into-gemini-cli-with-taylor-mullen#:~:text=%2A%20Utilize%20the%20google,summary%20directly%20to%20Google%20Docs)に直接保存できる「Google Docs MCP」サーバーを披露しました。アイデアとしては、Geminiが組み込みツールでは処理できないアクションを実行する必要があるときはいつでも、MCPサーバーに委譲できるということです。

**追加方法:** `settings.json` またはCLIを使用してMCPサーバーを構成できます。素早いセットアップには、CLIコマンドを試してください：

```bash
gemini mcp add myserver --command "python3 my_mcp_server.py" --port 8080
```

これにより、指定されたコマンド（ここではPythonモジュール）を実行してポート8080で起動する "myserver" という名前のサーバーが登録されます。`~/.gemini/settings.json` には、`mcpServers` の下にエントリが追加されます。例えば：

```json
"mcpServers": {
  "myserver": {
    "command": "python3",
    "args": ["-m", "my_mcp_server", "--port", "8080"],
    "cwd": "./mcp_tools/python",
    "timeout": 15000
  }
}
```

この構成（公式ドキュメントに基づく）は、GeminiにMCPサーバーの起動方法と[場所](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Example%20)を伝えます。実行されると、そのサーバーが提供するツールがGemini CLIで利用可能になります。以下のスラッシュコマンドですべてのMCPサーバーとそのツールを一覧表示できます：

```bash
/mcp
```

これにより、登録されているすべてのサーバーと、それらが[公開](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Command%20Description%20,List%20active%20extensions)しているツール名が表示されます。

**MCPの力:** MCPサーバーは**リッチでマルチモーダルな結果**を提供できます。例えば、MCP経由で提供されるツールは、Gemini [CLI](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Capabilities%3A)への応答の一部として画像やフォーマットされたテーブルを返すことができます。また、OAuth 2.0もサポートしているため、[資格情報](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Extend%20the%20CLI%20with%20your,add%7Clist%7Cremove%3E%60%20commands)を公開することなく、MCPツール経由でAPI（GoogleのAPI、GitHubなど）に安全に接続できます。基本的に、コードが書けるなら、それをMCPツールとしてラップできます - Gemini CLIを多くのサービスのオーケストレーションハブに変えることができます。

**デフォルト vs カスタム:** デフォルトでは、Gemini CLIの組み込みツールは多くのこと（ファイルの読み取り、Web検索、シェルコマンドの実行など）をカバーしますが、MCPを使えばそれを超えることができます。一部の上級ユーザーは、内部システムとのインターフェースや特殊なデータ処理を行うためのMCPサーバーを作成しています。例えば、会社のデータベースでSQLクエリを実行するための `/query_db` ツールを提供する `database-mcp` や、自然言語でチケットを作成するための `jira-mcp` などです。

独自のサーバーを作成する際は、セキュリティに注意してください：デフォルトでは、カスタムMCPツールは信頼済みとしてマークしない限り確認が必要です。サーバーに対して `trust: true`（ツールアクションを自動承認する）のような設定を行うか、特定の安全なツールをホワイトリストに登録し、危険なツールをブラックリストに[登録](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,takes%20precedence)することで安全性を制御できます。

要するに、**MCPサーバーは無限の統合を解き放ちます**。これは、Gemini CLIを、AIアシスタントとあなたが連携させる必要のあるあらゆるシステムとの間の接着剤にするプロ機能です。構築に興味がある場合は、公式[MCPガイド](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Transport%20)とコミュニティの例を確認してください。

## ヒント 4: メモリの追加と呼び出しを活用する

**クイックユースケース:** AIの長期記憶に重要な事実を追加することで、すぐに使えるようにしておきます。例えば、データベースポートやAPIトークンを解明した後、次のようにできます：

```bash
/memory add "ステージングのRabbitMQはポート5673にある"
```

これにより、その事実が保存されるため、あなた（またはAI）が[後で](https://binaryverseai.com/gemini-cli-open-source-ai-tool/#:~:text=Gemini%20CLI%20Ultimate%20Agent%3A%2060,a%20branch%20of%20conversation)忘れることはありません。その後、いつでも `/memory show` でメモリ内のすべてを呼び出すことができます。

`/memory` コマンドは、シンプルながら強力な*持続的メモリ*のメカニズムを提供します。`/memory add <text>` を使用すると、指定されたテキストがプロジェクトのグローバルコンテキスト（技術的には、グローバルの `~/.gemini/GEMINI.md` ファイルまたはプロジェクトの [`GEMINI.md`](https://genmind.ch/posts/Howto-Supercharge-Your-Terminal-with-Gemini-CLI/#:~:text=,load%20memory%20from%20%60GEMINI.md) に保存されます）に追加されます。AIの仮想掲示板にメモを取って留めておくようなものです。一度追加されると、セッションをまたいで、AIは将来の対話のためのプロンプトコンテキストで常にそのメモを見るようになります。

例を考えてみましょう：問題をデバッグしていて、自明ではない洞察（「設定フラグ `X_ENABLE` を `true` に設定しないとサービスが起動しない」）を得たとします。これをメモリに追加しておけば、後であなたやAIが関連する問題について議論しているときに、この重要な詳細を見落とすことはありません - それはコンテキストにあるからです。

**`/memory` の使用:**

* `/memory add "<text>"` - 事実やメモをメモリ（持続的コンテキスト）に追加します。これにより、`GEMINI.md` が新しいエントリですぐに更新されます。

* `/memory show` - メモリの完全な内容（つまり、現在読み込まれている結合されたコンテキストファイル）を表示します。

* `/memory refresh` - ディスクからコンテキストを再読み込みします（Gemini CLIの外で `GEMINI.md` ファイルを手動で編集した場合や、複数人で共同作業している場合に便利です）。

メモリはMarkdownで保存されるため、`GEMINI.md` ファイルを手動で編集して情報を整理・選別することもできます。`/memory` コマンドは会話中の利便性のためにあり、エディタを開く必要をなくします。

**プロのヒント:** この機能は「決定ログ」に最適です。チャット中にアプローチやルール（使用するライブラリや合意されたコードスタイルなど）を決定したら、それをメモリに追加します。そうすれば、AIはその決定を覚え、後で矛盾することを避けます。数時間や数日に及ぶ可能性のある長いセッションでは特に便利です - キーポイントを保存することで、会話が長くなったときにモデルが以前のコンテキストを忘れがちになるのを軽減します。

もう一つの使い方は個人的なメモです。`~/.gemini/GEMINI.md`（グローバルメモリ）はすべてのセッションで読み込まれるため、そこに一般的な好みや情報を入れることができます。例えば、「ユーザーの名前はアリスです。丁寧に話し、スラングは避けてください。」などです。AIのペルソナやグローバル知識を設定するようなものです。ただし、グローバルメモリは*すべての*プロジェクトに適用されるため、プロジェクト固有の情報で散らかさないように注意してください。

要約すると、**メモリの追加と呼び出し**は、Gemini CLIが状態を維持するのに役立ちます。プロジェクトと共に成長するナレッジベースと考えてください。同じことを繰り返さないようにするため、あるいはAIがゼロから再発見しなければならない事実を思い出させるために使用してください。

## ヒント 5: チェックポイントと `/restore` を元に戻すボタンとして使用する

**クイックユースケース:** Gemini CLIが行った一連のファイル変更に不満がある場合、*即座に以前の状態にロールバック*できます。Geminiを起動するとき（または設定で）チェックポイント機能を有効にし、`/restore` コマンドを使用して、軽量なGit [revert](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,Exit%20the%20Gemini%20CLI)のように変更を元に戻します。`/restore` はワークスペースを保存されたチェックポイントにロールバックします。チェックポイントがどのようにキャプチャされたかによって、会話の状態も影響を受ける場合があります。

Gemini CLIの**チェックポイント**機能はセーフティネットとして機能します。有効にすると、CLIは[ファイル](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=When%20,snapshot%20before%20tools%20modify%20files)を変更する各ツール実行の*前に*、プロジェクトファイルのスナップショットを取得します。何か問題が発生した場合は、最後の既知の良好な状態に戻すことができます。AIのアクションに対するバージョン管理のようなものですが、毎回手動でGitにコミットする必要はありません。

**使用方法:** `--checkpointing` フラグを指定してCLIを起動することで、チェックポイントをオンにできます：

```bash
gemini --checkpointing
```

あるいは、設定（[`settings.json`](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%7B%20,true) 内の `"checkpointing": { "enabled": true }`）に追加してデフォルトにすることもできます。アクティブになると、Geminiがファイルに書き込もうとするたびに、「Checkpoint saved.（チェックポイントが保存されました）」のようなメッセージが表示されます。

AIによる編集に問題があるとわかった場合、2つのオプションがあります：

* `/restore list`（または引数なしの `/restore`）を実行して、タイムスタンプと説明付きの最近のチェックポイント一覧を表示する。

* `/restore <id>` を実行して、特定のチェックポイントにロールバックする。idを省略し、保留中のチェックポイントが1つしかない場合は、[デフォルト](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=Step)でそのチェックポイントに復元します。

例えば：

```bash
/restore
```

Gemini CLIは以下のように出力するかもしれません：

0: [2025-09-22 10:30:15] Before running 'apply_patch'  
1: [2025-09-22 10:45:02] Before running 'write_file'

その後、`/restore 0` を実行して、すべてのファイル変更（さらには会話コンテキスト）をそのチェックポイントの状態に戻すことができます。このようにして、誤ったコードリファクタリングや、Geminiが[行った](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=1,point%20and%20roll%20back%20instantly)その他の変更を「元に戻す」ことができます。

**復元されるもの:** チェックポイントは、作業ディレクトリ（Gemini CLIが変更を許可されているすべてのファイル）の状態とワークスペースファイル（チェックポイントのキャプチャ方法によっては会話状態もロールバックされる場合があります）をキャプチャします。復元すると、ファイルは古いバージョンに上書きされ、会話メモリはそのスナップショットにリセットされます。AIエージェントを間違った方向に進む前の時間にタイムトラベルさせるようなものです。外部的な副作用（例えば、AIがデータベースマイグレーションを実行した場合、それを元に戻すことはできません）は元に戻らないことに注意してください。しかし、ファイルシステムとチャットコンテキスト内のものはすべて対象です。

**ベストプラクティス:** 些細でないタスクの場合、チェックポイントをオンにしておくのが良い考えです。オーバーヘッドは小さく、安心感を与えてくれます。チェックポイントが不要だとわかった場合（すべてうまくいった場合）は、いつでもクリアするか、次のチェックポイントで上書きさせればよいのです。開発チームは、特にマルチステップの[コード編集](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=Tips%20to%20avoid%20messy%20rollbacks)の前にチェックポイントを使用することを推奨しています。ただし、ミッションクリティカルなプロジェクトの場合でも、主要なセーフティ[ネット](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=No,VS%20Code%20is%20already%20free)として適切なバージョン管理（`git`）を使用すべきです。チェックポイントは完全なVCSではなく、迅速なやり直しのための利便性と考えてください。

本質的に、`/restore` により、自信を持ってGemini CLIを使用できます。必要なら巻き戻すための*「緊急」ボタン*があることを知っているため、AIに大胆な変更を試させることができます。
## ヒント 6: Google Docs、Sheetsなどを読み込む

**クイックユースケース:** 何らかの仕様やデータが書かれたGoogle DocやSheetがあり、AIにそれを使わせたいとしましょう。内容をコピー＆ペーストする代わりに、リンクを提供すれば、構成されたWorkspace MCPサーバーを使ってGemini CLIがそれを取得して読み込むことができます。

例えば：

```bash
このデザインドキュメントの要件を要約して: https://docs.google.com/document/d/<id>
```

GeminiはそのDocの内容を取り込み、応答に組み込むことができます。同様に、Google SheetsやDriveファイルをリンクで読み込むことができます。

**仕組み:** これらの機能は通常、**MCP統合**によって有効になります。GoogleのGemini CLIチームは、Google Workspace用のコネクタを構築しました（または開発中です）。一つのアプローチは、URLまたは[ID](https://github.com/google-gemini/gemini-cli/issues/7175)が与えられたときに、GoogleのAPI（Docs API、Sheets APIなど）を使用してドキュメントコンテンツを取得する小さなMCPサーバーを実行することです。構成済みであれば、`/read_google_doc` のようなスラッシュコマンドやツール、あるいはGoogle Docsのリンクを見て適切なツールを自動的に呼び出す自動検出機能を持つことができます。

例えば、Agent Factoryポッドキャストのデモで、チームは**Google Docs MCP**を使用して要約を直接[ドキュメント](https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-deep-dive-into-gemini-cli-with-taylor-mullen#:~:text=%2A%20Utilize%20the%20google,summary%20directly%20to%20Google%20Docs)に保存しました。これは、そもそもドキュメントの内容を読み取ることができたことを意味します。実際には、以下のようにするでしょう：

```bash
@https://docs.google.com/document/d/XYZ12345
```

URLに `@`（コンテキスト参照構文）を含めると、Gemini CLIにそのリソースを取得するよう合図します。Google Doc統合があれば、そのドキュメントの内容はローカルファイルであるかのように取り込まれます。そこから、AIはそれを要約したり、質問に答えたり、会話で利用したりできます。

同様に、Google Driveの**ファイルリンク**を貼り付けると、適切に構成されたDriveツールがそのファイルをダウンロードまたは開くことができます（権限とAPIアクセスが設定されていると仮定して）。**Google Sheets**は、セル範囲のクエリや読み取りを実行するMCP経由で利用可能になり、「このSheet [リンク] の予算列の合計は？」といった質問をしてAIに計算させることができます。

**セットアップ:** 執筆時点では、Google Workspace統合には多少の手間（API認証情報の取得、[Kanshi Tanaike](https://medium.com/google-cloud/managing-google-docs-sheets-and-slides-by-natural-language-with-gemini-cli-and-mcp-62f4dfbef2d5#:~:text=To%20implement%20this%20approach%2C%20I,methods%20for%20each%20respective%20API)氏が説明しているようなMCPサーバーの実行など）が必要かもしれません。公式のGemini CLIリポジトリやコミュニティフォーラムですぐに使える拡張機能をチェックしてください。例えば、公式のGoogle Docs MCPがプラグイン/拡張機能として利用可能になるかもしれません。やる気があれば、MCP[サーバー](https://github.com/google-gemini/gemini-cli/issues/7175#:~:text=)内でGoogle APIを使用する方法に関するガイドに従って作成することもできます。通常、OAuthの処理（Gemini CLIはMCPサーバーに対してこれをサポートしています）を行い、`read_google_doc` のようなツールを公開します。

**使用上のヒント:** これらのツールがある場合、プロンプトでリンクを提供するだけ（AIが自動的にツールを呼び出して取得するかもしれません）や、`/doc open <URL>` のようなスラッシュコマンドを使用するだけで済みます。`/tools` をチェックして、利用可能なコマンドを確認してください - Gemini CLIはすべてのツールとカスタムコマンドを[そこ](https://dev.to/therealmrmumba/7-insane-gemini-cli-tips-that-will-make-you-a-superhuman-developer-2d7h#:~:text=Gemini%20CLI%20includes%20dozens%20of,can%20supercharge%20your%20dev%20process)にリストします。

要約すると、**Gemini CLIはローカルファイルシステムを超えて手を伸ばすことができます**。Google Docs、Sheets、Drive、その他の外部コンテンツであっても、参照によってデータを取り込むことができます。このプロのヒントにより、手動のコピー＆ペーストから解放され、コンテキストフローが自然に保たれます - 必要なドキュメントやデータセットを参照するだけで、AIが必要なものを取得します。これはGemini CLIを、ディスク上のファイルだけでなく、アクセス可能なすべての情報のための真の**ナレッジアシスタント**にします。

*（注：プライベートドキュメントへのアクセスには、当然ながらCLIに適切な権限が必要です。統合がセキュリティとプライバシーを尊重していることを常に確認してください。企業設定では、このような統合のセットアップに追加の認証ステップが必要になる場合があります。）*

## ヒント 7: 明示的なコンテキストのために `@` でファイルや画像を参照する

**クイックユースケース:** ファイルの内容や画像を言葉で説明する代わりに、Gemini CLIに直接指し示します。`@` 構文を使用すると、ファイル、ディレクトリ、または画像をプロンプトに添付できます。これにより、AIはそれらのファイルにあるものを正確に[コンテキスト](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Reference%20files%20or%20directories%20in,PDFs%2C%20audio%2C%20and%20video%20files)として見ることができます。例えば：

```bash
このコードを説明して: @./src/main.js
```

これにより、`src/main.js` の内容がプロンプトに含まれるため（Geminiのコンテキストサイズ制限まで）、AIはそれを読んで[説明](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Include%20a%20single%20file%3A)できます。

この `@` *ファイル参照*は、開発者にとってGemini CLIの最も強力な機能の1つです。曖昧さを排除します - ファイルについてモデルの記憶や推測に頼るよう求めているのではなく、文字通り読むべきファイルを渡しているのです。ソースコード、テキストドキュメント、ログなどにこれを使用できます。同様に、**ディレクトリ全体**を参照することもできます：

```bash
@./utils/ のコードをリファクタリングして async/await を使用するようにして。
```

パスの末尾にスラッシュを付けることで、Gemini CLIはその[ディレクトリ](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Include%20a%20whole%20directory%20)からファイルを再帰的に含めます（常識的な範囲内で、無視ファイルやサイズ制限を尊重します）。AIは関連するすべてのモジュールを一緒に考慮できるため、これは複数ファイルのリファクタリングや分析に最適です。

さらに印象的なのは、プロンプトで**画像などのバイナリファイル**を参照できることです。Gemini CLI（Geminiモデルのマルチモーダル機能を使用）は画像を理解できます。例えば：

```bash
このスクリーンショットに見えるものを説明して: @./design/mockup.png
```

画像がモデルに供給され、AIは「これは青いサインインボタンとヘッダー画像があるログインページです」のような応答をする[でしょう](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Include%20an%20image%3A)。。用途は想像できます：UIモックアップのレビュー、写真の整理（後のヒントで説明します）、画像からのテキスト抽出（GeminiはOCRも可能です）などです。

`@` 参照を効果的に使用するためのいくつかの注意点：

* **ファイル制限:** Gemini 2.5 Proは巨大なコンテキストウィンドウ（最大100万[トークン](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=To%20use%20Gemini%20CLI%20free,per%20day%20at%20no%20charge)）を持っているため、かなり大きなファイルや多数のファイルを含めることができます。ただし、極端に大きなファイルは切り捨てられる場合があります。ファイルが巨大な場合（例えば数十万行）、要約するか部分に分けることを検討してください。参照が大きすぎる場合やサイズのためにスキップされた場合、Gemini CLIは警告します。

* **自動無視:** デフォルトでは、Gemini CLIはディレクトリ[コンテキスト](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Reference%20files%20or%20directories%20in,PDFs%2C%20audio%2C%20and%20video%20files)を取り込む際に `.gitignore` と `.geminiignore` ファイルを尊重します。したがって、プロジェクトルートを `@./` しても、巨大な無視されたフォルダ（`node_modules` など）をプロンプトにダンプすることはありません。`.gitignore` の仕組みと同様に、`.geminiignore` で無視パターンをカスタマイズできます。

* **明示的 vs 暗黙的コンテキスト:** Taylor Mullen氏（Gemini CLIの作成者）は、モデルの記憶に頼ったり自分で要約したりするのではなく、`@` を使用した*明示的なコンテキスト注入*を強調しています。これはより正確で、AIがコンテンツを幻覚（ハルシネーション）するのを防ぎます。可能な限り、`@` 参照を使用して真実のソース（コード、設定ファイル、ドキュメント）をAIに示してください。この実践により、精度が大幅に向上します。

* **参照の連鎖:** 1つのプロンプトに複数のファイルを含めることができます：

```bash
@./foo.py と @./bar.py を比較して違いを教えて。
```

CLIは両方のファイルを含めます。トークン制限に注意してください。複数の大きなファイルはコンテキストウィンドウを多く消費する可能性があります。

`@` を使用することは、基本的に**その場でGemini CLIに知識を供給する方法**です。これはCLIを、テキストや画像を処理できるマルチモーダルリーダーに変えます。プロユーザーとして、これを活用する習慣をつけてください - 「ファイルXを開いてYをして」（AIが勝手にやるかどうかわからない）と頼むよりも、多くの場合、速くて信頼性が高いです。代わりに、作業するためのXを明示的に渡すのです。

## ヒント 8: その場でのツール作成（Geminiにヘルパーを作らせる）

**クイックユースケース:** 手元のタスクが小さなスクリプトやユーティリティの恩恵を受ける場合、Gemini CLIにそのツールを作成するよう依頼できます - まさにセッションの中で。例えば、「このフォルダ内のすべてのJSONファイルを解析し、エラーフィールドを抽出するPythonスクリプトを書いて」と言うことができます。Geminiはスクリプトを生成でき、それをCLI経由で実行できます。本質的に、進めながら**ツールセットを動的に拡張**できます。

Gemini CLIは既存のツールに限定されません。必要に応じて新しいものを製造するためにコーディング能力を使用できます。これはよく暗黙的に起こります：複雑なことを頼むと、AIは一時ファイル（コード付き）を作成して実行することを提案するかもしれません。ユーザーとして、このプロセスを明示的にガイドすることもできます：

* **スクリプトの作成:** 選択した言語でスクリプトやプログラムを作成するようGeminiに促すことができます。ファイルを作成するために `write_file` ツールを使用する可能性が高いです。例えば：

```bash
現在のディレクトリにあるすべての '.log' ファイルを読み取り、それぞれの行数を報告するNode.jsスクリプトを生成して。
```

Gemini CLIはコードをドラフトし、あなたの承認を得てファイル（例：`script.js`）に書き込みます。その後、`!` シェルコマンドを使用して（例：`!node script.js`）実行するか、Gemini CLIに実行を依頼する（AIが計画の一部と判断した場合、自動的に `run_shell_command` を使用して、今書いたスクリプトを実行するかもしれません）ことができます。

* **MCP経由の一時ツール:** 高度なシナリオでは、AIは特殊なタスクのためにMCPサーバーを起動することさえ提案するかもしれません。例えば、プロンプトにPythonで行うのが適した重いテキスト処理が含まれる場合、GeminiはPythonでシンプルなMCPサーバーを生成して実行するかもしれません。これは稀ですが、AIがその場で新しい「エージェント」をセットアップできることを示しています。（Gemini CLIチームのスライドの1つは、「すべてにMCPサーバー、LROwnと呼ばれるものさえある」とユーモアたっぷりに言及していました - Geminiに自分自身や別のモデルのインスタンスを実行させることができることを示唆していますが、それは実用的な用途というよりはトリックです！）。

ここでの主な利点は**自動化**です。ヘルパースクリプトを書くために手作業を止める代わりに、フローの一部としてAIにやらせることができます。オンデマンドでツールを作成できるアシスタントがいるようなものです。これは、組み込みツールが直接提供していないデータ変換タスク、バッチ操作、または使い捨ての計算に特に役立ちます。

**ニュアンスと安全性:** Gemini CLIが新しいツールのコードを書くときは、実行する前に確認する必要があります。`/diff` ビュー（Geminiは書き込む前にファイルの差分を表示します）は、[コード](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=Nobody%20enjoys%20switching%20between%20windows,track%20changes%20line%20by%20line)を検査する機会です。期待通りに動作し、悪意があったり破壊的であったりしないことを確認してください（プロンプトが明示的に求めない限り、AIは有害なものを生成すべきではありませんが、AIからのコードと同様に、特に多くのデータを削除または変更するスクリプトの場合は、ロジックをダブルチェックしてください）。

**シナリオ例:** CSVファイルがあり、複雑な方法でフィルタリングしたいとします。Gemini CLIに依頼すると、「CSVを解析してフィルタを適用するPythonスクリプトを書きます」と言うかもしれません。そして `filter_data.py` を作成します。承認して実行し、結果が得られたら、そのスクリプトは二度と必要ないかもしれません。このツールの儚い作成はプロの動きです - AIが自律的にその能力を効果的に拡張していることを示しています。

**プロのヒント:** スクリプトが即時のコンテキストを超えて有用であるとわかった場合は、それを永続的なツールやコマンドに昇格させることができます。例えば、AIが素晴らしいログ処理スクリプトを生成した場合、後で再利用しやすいようにカスタムスラッシュコマンド（ヒント #2）に変えることができます。Geminiの生成力と拡張フックの組み合わせは、CLIを使用するにつれてツールキットが継続的に進化できることを意味します。

要約すると、**Geminiを既製品に限定しないでください**。問題を解決するために新しいプログラムやミニサーバーさえも即座に作り出せるジュニア開発者として扱ってください。このアプローチはGemini CLIのエージェンティックな哲学を体現しています - たとえその場でコードを書かなければならないとしても、必要なツールを見つけ出します。

## ヒント 9: システムのトラブルシューティングと構成にGemini CLIを使用する

**クイックユースケース:** コードプロジェクトの外でGemini CLIを実行して、一般的なシステムタスクを支援することができます - OSのためのインテリジェントなアシスタントと考えてください。例えば、シェルがおかしい場合、ホームディレクトリでGeminiを開き、「私の `.bashrc` ファイルを直して、エラーがあるんだ」と頼むことができます。Geminiは設定ファイルを開いて編集してくれます。

このヒントは、**Gemini CLIはコーディングプロジェクトのためだけのものではなく、開発環境全体のためのAIヘルパーである**ことを強調しています。多くのユーザーが、マシンの開発セットアップのカスタマイズや問題の修正にGeminiを使用しています：

* **ドットファイルの編集:** シェル設定（`.bashrc` または `.zshrc`）を参照（`@~/.bashrc`）して読み込み、Gemini CLIに最適化やトラブルシューティングを依頼できます。例えば、「`PATH` がGoのバイナリを拾っていないんだけど、`.bashrc` を編集して直してくれる？」と頼むと、AIは正しい `export` 行を挿入できます。変更を保存する前に、確認のために差分を表示します。

* **エラーの診断:** ターミナルやアプリケーションログで不可解なエラーに遭遇した場合、それをコピーしてGemini CLIに供給できます。エラーメッセージを分析し、解決策を提案してくれることがよくあります。これはStackOverflowやGoogleを使用するのと似ていますが、AIがあなたのシナリオを直接検討してくれる点が異なります。例えば：「`npm install` を実行すると `EACCES` 権限エラーが出る - どうすれば直る？」と聞くと、Geminiはそれが `node_modules` の権限の問題であると検出し、ディレクトリの所有権を変更するか、適切なノードバージョンマネージャーを使用するように案内するかもしれません。

* **プロジェクト外での実行:** デフォルトでは、`.gemini` コンテキストのないディレクトリで `gemini` を実行しても、プロジェクト固有のコンテキストが読み込まれないだけで、CLIは完全に使用できます。これは、システムのトラブルシューティングのようなアドホックなタスクに最適です。考慮すべきコードファイルはないかもしれませんが、それでもCLIを通じてシェルコマンドを実行したり、Web情報を取得させたりできます。基本的に、単にチャットするだけでなく、自分のために物事を*実行*できるAI搭載ターミナルとしてGemini CLIを扱っていることになります。

* **ワークステーションのカスタマイズ:** 設定を変更したり、新しいツールをインストールしたいですか？ Gemini CLIに「システムにDockerをインストールして」や「GitがGPGでコミットに署名するように設定して」と頼むことができます。CLIは手順を実行しようとします。Webから（検索ツールを使用して）指示を取得し、適切なシェルコマンドを実行するかもしれません。もちろん、何をしているか常に監視し、コマンドを承認してください - しかし、マルチステップのセットアッププロセスを自動化することで時間を節約できます。実際の例：あるユーザーがGemini CLIに「macOSのDockの設定を自動的に隠れるようにし、遅延をなくして」と頼んだところ、AIは必要な `defaults write` コマンドを実行することができました。

このモードは、Gemini CLIを**スマートシェル**として使用するものと考えてください。実際、これをヒント16（シェルパススルーモード）と組み合わせることができます - `!` シェルモードに入って何かを確認し、その後AIモードに戻って出力を分析させることもあります。

**注意点:** システムレベルのタスクを行うときは、広範な影響を与えるコマンド（`rm -rf` やシステム設定の変更など）に注意してください。Gemini CLIは通常、確認を求めますし、あなたが見ていないところで何も実行しません。しかし、パワーユーザーとして、どのような変更が行われているかを感じ取る必要があります。確信が持てない場合は、実行する前にコマンドを説明するようにGeminiに頼んでください（例：「`defaults write com.apple.dock autohide-delay -float 0` が何をするか説明して」 - そのように促せば、単に実行するのではなく喜んで説明してくれます）。

**トラブルシューティングボーナス:** もう一つの気の利いた使い方は、Gemini CLIを使用してログや設定ファイルを解析し、問題を探すことです。例えば、「このApache設定の間違いをスキャンして」（`@httpd.conf` を付けて）、または「昨日の午後2時頃のエラーをsyslogから探して」（アクセス可能なら `@/var/log/syslog` を付けて）。共同管理者がいるようなものです。クラッシュの原因らしきものを提案したり、一般的なエラーパターンに対する修正を提案したりすることさえできます。

要約すると、**環境の問題に対するアシスタントとしてGemini CLIを起動することを躊躇しないでください**。コードを書くだけでなく、コードを書くシステムを維持するためにも、すべてのワークフローを加速するために存在します。多くのユーザーが、Geminiの助けを借りて開発環境をカスタマイズすることは、退屈で複雑なセットアップ手順を処理するために常に電話に出られる技術者の相棒がいるような気分だと報告しています。

## ヒント 10: YOLOモード - ツールアクションの自動承認（注意して使用）

**クイックユースケース:** 自信がある（または冒険的な）場合は、毎回確認を求めることなくGemini CLIにツールアクションを実行させることができます。これが**YOLOモード**（You Only Live Once: 人生は一度きり）です。`--yolo` フラグを使用するか、[セッション](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,prompt%20in%20an%20external%20editor)中に `Ctrl+Y` を押すことで有効になります。YOLOモードでは、AIがツール（シェルコマンドの実行やファイルへの書き込みなど）を決定するとすぐに、あの「承認しますか？ (y/n)」というプロンプトなしに実行されます。

**なぜYOLOモードを使うのか？** 主に、**AIのアクションを信頼している場合**のスピードと利便性のためです。経験豊富なユーザーは、多くの反復的な安全な操作を行っている場合にYOLOをオンにするかもしれません。例えば、Geminiに10個の異なるファイルを次々に生成するように依頼した場合、それぞれを承認するのはフローを遅くします。YOLOモードなら、それらすべてを自動的に書き込ませるだけです。別のシナリオは、完全に自動化されたスクリプトやCIパイプラインでGemini CLIを使用する場合です - 確認のために一時停止しないように、`--yolo` を指定してヘッドレスで実行するかもしれません。

最初からYOLOモードで開始するには、以下でCLIを起動します：

```bash
gemini --yolo
```

または短縮形の `gemini -y`。自動承認が[オン](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=initial%20prompt.%20%2A%20%60,to%20revert%20changes)になっていることを示す何らかの表示（異なるプロンプトや通知など）がCLIに表示されます。インタラクティブセッション中は、いつでも **Ctrl+Y** を押すことで切り替えること[ができ](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,prompt%20in%20an%20external%20editor)、通常、CLIはフッターに「YOLO mode enabled (all actions auto-approved)」のようなメッセージを表示します。

**大きな警告:** YOLOモードは強力ですが**危険**です。Geminiチーム自身も「大胆なユーザー向け」とラベル付けしています - つまり、AIが危険なコマンドを尋ねることなく実行する可能性があることを認識しておく必要があります。通常モードでは、AIが `rm -rf /`（最悪のシナリオ）を実行しようと決めても、明らかに拒否するでしょう。YOLOモードでは、そのコマンドは即座に実行されます（そしておそらくあなたの一日を台無しにします）。そのような極端な間違いはありそうにありませんが（AIのシステムプロンプトには安全ガイドラインが含まれています）、確認の要点は望ましくないアクションをキャッチすることです。YOLOはそのセーフティネットを取り除きます。

**YOLOのベストプラクティス:** 完全なリスクなしにある程度の利便性を求める場合は、特定のコマンドの*許可リスト*を検討してください。例えば、特定のツールやコマンドパターンは確認を必要としないように設定で構成できます（すべての `git` コマンドや読み取り専用アクションを許可するなど）。実際、Gemini CLIは特定のコマンドの確認をスキップするための設定をサポートしています：例えば、`"tools.shell.autoApprove": ["git ", "npm test"]` のように設定して、[それら](https://google-gemini.github.io/gemini-cli/docs/cli/configuration.html#:~:text=match%20at%20L247%20%60%5B,Default%3A%20%60undefined)を常に実行するようにできます。こうすれば、グローバルにYOLOモードにする必要はなく、安全なコマンドのみを選択的にYOLOできます。別のアプローチ：YOLOを使用する場合はGeminiをサンドボックスまたはコンテナで実行します。そうすれば、たとえ無茶なことをしても、システムは隔離されます（GeminiにはDocker[コンテナ](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=echo%20,gemini)でツールを実行するための `--sandbox` フラグがあります）。

多くの上級ユーザーは、YOLOを頻繁にオン/オフします - 一連の小さなファイル編集やクエリを行うときはオンにし、クリティカルなことをしようとするときはオフにします。キーボードショートカットを素早いトグルとして使用して、同じことができます。

要約すると、**YOLOモードは監視を犠牲にして摩擦を排除します**。これは慎重かつ賢明に使用すべきプロ機能です。それは本当にAIへの信頼（または無鉄砲さ！）を示しています。Gemini CLIに不慣れな場合は、何をする傾向があるかというパターンを明確に理解するまで、YOLOは避けるべきでしょう。使用する場合は、万が一に備えてバージョン管理やバックアップを二重に行ってください。

*（慰めになるかわかりませんが、あなたは一人ではありません - コミュニティの多くが「YOLOしたらGeminiがクレイジーなことをした」と冗談を言っています。ですから使ってください、でも... まあ、人生は一度きりですから。）*

## ヒント 11: ヘッドレス＆スクリプティングモード（Gemini CLIをバックグラウンドで実行）

**クイックユースケース:** **ヘッドレスモード**で実行することで、スクリプトや自動化でGemini CLIを使用できます。つまり、コマンドライン引数や環境変数を介してプロンプト（または完全な会話）を提供し、Gemini CLIが出力を生成して終了します。これは他のツールと統合したり、スケジュールに従ってAIタスクをトリガーしたりするのに最適です。

例えば、REPLを開かずに一度限りの回答を得るには、`gemini -p "...prompt..."` を使用できることを見てきました。これはすでにヘッドレス使用です：モデルの応答を出力して[シェル](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Non,and%20get%20a%20single%20response)に戻ります。しかし、さらにできることがあります：

* **システムプロンプトのオーバーライド:** カスタムのシステムペルソナや指示セット（デフォルトとは異なる）でGemini CLIを実行したい場合は、環境変数 `GEMINI_SYSTEM_MD` を使用できます。これを設定することで、Gemini CLIに組み込みのシステムプロンプトを無視し、[代わり](https://medium.com/google-cloud/practical-gemini-cli-bring-your-own-system-instruction-19ea7f07faa2#:~:text=The%20,rather%20than%20its%20hardcoded%20defaults)に提供されたファイルを使用するように指示します。例えば：

```bash
export GEMINI_SYSTEM_MD="/path/to/custom_system.md"
gemini -p "タスクXを細心の注意を払って実行して"
```

これにより、[プロンプト](https://medium.com/google-cloud/practical-gemini-cli-bring-your-own-system-instruction-19ea7f07faa2#:~:text=The%20feature%20is%20enabled%20by,specific%20configurations)を実行する前に、`custom_system.md` がシステムプロンプト（AIが従う「役割」とルール）として読み込まれます。また、`GEMINI_SYSTEM_MD=true` を設定すると、CLIは現在のプロジェクトの `.gemini` [ディレクトリ](https://medium.com/google-cloud/practical-gemini-cli-bring-your-own-system-instruction-19ea7f07faa2#:~:text=The%20feature%20is%20enabled%20by,specific%20configurations)にある `system.md` という名前のファイルを探します。この機能は非常に高度です - 基本的にCLIの*組み込みの頭脳を独自の指示に置き換える*ことができ、一部のユーザーはこれを行って（特定のペルソナをシミュレートしたり、超厳格なポリシーを強制したりするなど）特殊なワークフローを実現しています。コアプロンプトにはAIがどのように[ツール](https://medium.com/google-cloud/practical-gemini-cli-bring-your-own-system-instruction-19ea7f07faa2#:~:text=If%20you%20read%20my%20previous,proper%20functioning%20of%20Gemini%20CLI)を選択して使用するかについての重要な指示が含まれているため、コアプロンプトを置き換えるとツールの使用に影響を与える可能性があるため、注意して使用してください。

* **CLI経由の直接プロンプト:** `-p` 以外にも、`-i`（インタラクティブプロンプト）があり、これは初期プロンプトでセッションを開始し、そのまま開いたままにします。例えば： `gemini -i "こんにちは、デバッグしましょう"` はREPLを開き、すでにモデルに挨拶を済ませています。これは開始時に最初の質問をすぐにしたい場合に便利です。

* **シェルパイプによるスクリプト化:** テキストだけでなく、ファイルやコマンド出力もGeminiにパイプできます。例えば： `gemini -p "このログを要約して:" < big_log.txt` は `big_log.txt` の内容を（「このログを要約して:」というフレーズの後に）プロンプトに供給します。あるいは `some_command | gemini -p "上記の出力を踏まえて、何が悪かったの？"` とすることもできます。この手法により、UnixツールとAI分析を組み合わせることができます。これはシングルパス操作であるという意味でヘッドレスです。

* **CI/CDでの実行:** ビルドプロセスにGemini CLIを組み込むことができます。例えば、CIパイプラインでテストを実行し、その後Gemini CLIを使用して失敗したテスト出力を自動的に分析し、コメントを投稿させることができます。`-p` フラグと環境認証を使用すれば、これをスクリプト化できます。（もちろん、環境にAPIキーまたは必要な認証があることを確認してください。）

もう1つのヘッドレスのトリック：**`--format=json` フラグ**（または設定）。Gemini CLIは、構成すれば人間が読めるテキストの代わりにJSON形式で応答を出力[できます](https://google-gemini.github.io/gemini-cli/docs/cli/configuration.html#:~:text=)。これはプログラムによる消費に役立ちます - スクリプトでJSONを解析して、回答やツールアクションの詳細を取得できます。

**なぜヘッドレスモードが重要なのか：** それはGemini CLIをインタラクティブなアシスタントから、他のプログラムが呼び出すことのできる**バックエンドサービス**やユーティリティに変えるからです。Gemini CLIのプロンプトを毎晩実行するcronjobをスケジュールできます（レポートの生成やAIロジックによる何かのクリーンアップを想像してください）。IDEのボタンを配線して、特定のタスクのためにヘッドレスのGemini実行をトリガーすることもできます。

**例:** ニュースウェブサイトの毎日の要約が欲しいとします。次のようなスクリプトを持てるでしょう：

```bash
gemini -p "Web-fetch \"https://news.site/top-stories\" and extract the headlines, then write them to headlines.txt"
```

`--yolo` を付ければ、ファイルの書き込み確認を求められません。これはWeb取得ツールを使用してページを取得し、ファイル書き込みツールを使用して見出しを保存します。すべて自動で、人間は介在しません。Gemini CLIをスクリプト可能なコンポーネントとして扱えば、可能性は無限大です。

要約すると、**ヘッドレスモード**は自動化を可能にします。それはGemini CLIと他のシステムの間の架け橋です。これをマスターするということは、AIの使用をスケールアップできるということです - ターミナルに入力しているときだけでなく、あなたがいないときでも、AIエージェントがあなたのために仕事をすることができます。

*（ヒント：本当に長時間実行される非インタラクティブなタスクの場合は、Gemini CLIの「Plan」モードや、介入なしでマルチステップの計画を生成する方法も調べると良いかもしれません。ただし、それらはこの範囲を超えた高度なトピックです。ほとんどの場合、ヘッドレスモードによる適切に作成された単一のプロンプトで多くのことを達成できます。）*

## ヒント 12: チャットセッションの保存と再開

**クイックユースケース:** Gemini CLIで問題を1時間デバッグしていて中断する必要がある場合でも、会話のコンテキストを失う必要はありません。`/chat save <name>` を使用してセッションを保存します。後で（CLIを再起動した後でも）、`/chat resume <name>` を使用して、中断したところから[再開](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,help%20information%20and%20available%20commands)できます。これにより、長時間にわたる会話をシームレスに一時停止し、継続することができます。

Gemini CLIは基本的に組み込みのチャットセッションマネージャーを持っています。知っておくべきコマンドは以下の通りです：

* `/chat save <tag>` - 現在の会話状態を、[提供](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,help%20information%20and%20available%20commands)したタグ/名前で保存します。タグはそのセッションのファイル名やキーのようなものです。頻繁に保存したい場合、存在すれば上書きされます。（説明的な名前を使用すると便利です - 例：`/chat save fix-docker-issue`。）

* `/chat list` - 保存したすべてのセッション（[使用](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,help%20information%20and%20available%20commands)したタグ）を一覧表示します。これにより、以前の保存名を思い出すことができます。

* `/chat resume <tag>` - そのタグのセッションを再開し、会話のコンテキストと履歴全体を[保存](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,help%20information%20and%20available%20commands)されたときと全く同じ状態に復元します。まるで離れなかったかのようです。そこからチャットを続けることができます。

* `/chat share` - （ファイルに保存）これはチャット全体を他の人と共有して、その人がセッションを継続できるため便利です。ほぼコラボレーションのようなものです。

内部的には、これらのセッションはおそらく `~/.gemini/chats/` または同様の場所に保存されます。それらには会話メッセージと関連する状態が含まれます。この機能は以下のようなケースで非常に役立ちます：

* **長いデバッグセッション:** AIとのデバッグは長いやり取りになることがあります。一度に解決できない場合は、保存して後で（おそらくリフレッシュした頭で）戻ってきます。コンテキスト全体がリロードされるため、AIは以前のすべてをまだ「覚えて」います。

* **数日にわたるタスク:** プロジェクトのアシスタントとしてGemini CLIを使用している場合、「モジュールXのリファクタリング」のために数日にわたるチャットセッションを持つかもしれません。その特定のチャットを毎日再開することで、コンテキストが毎日リセットされることはありません。一方で、別に保存された「ドキュメント作成」のための別のセッションを持つこともできます。コンテキストの切り替えは、一方を保存して他方を再開するだけです。

* **チームへの引き継ぎ:** これはより実験的ですが、理論的には、保存されたチャットの内容を同僚と共有できます（保存されたファイルはおそらくポータブルです）。彼らがそれを自分の `.gemini` ディレクトリに入れて再開すれば、同じコンテキストを見ることができます。コラボレーションのための**より実用的でシンプルなアプローチ**は、単に関連するQ&Aをログからコピーして共有の `GEMINI.md` やプロンプトを使用することですが、セッションデータを保持できることは注目に値します。

**使用例:**

```bash
/chat save api-upgrade
```

*（セッションは "api-upgrade" として保存されました）*

```bash
/quit
```

*（後で、CLIを再度開く）*

```bash
$ gemini
gemini> /chat list
```

*（表示: api-upgrade）*

```bash
gemini> /chat resume api-upgrade
```

これで、モデルは最後のやり取りの状態が整った状態であなたを迎えます。上にスクロールして、以前のすべてのメッセージが存在することを確認できます。

**プロのヒント:** [チャット](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=Naming%20conventions%20to%20keep%20projects,organized)を保存するときは意味のあるタグを使用してください。`/chat save session1` ではなく、トピックに関連した名前（例：`/chat save memory-leak-bug`）を付けます。これは後で `/chat list` 経由で正しいものを見つけるのに役立ちます。保存できるセッション数に厳密な制限は発表されていませんが、整理のために古いものを時々クリーンアップするのが賢明かもしれません。

この機能はGemini CLIを持続的なアドバイザーに変えます。会話で得た知識を失うことはありません。いつでも一時停止して再開できます。これは、閉じるとコンテキストを忘れてしまう他のAIインターフェースとの差別化要因です。パワーユーザーにとって、これは**作業の並列スレッドを維持できる**ことを意味します。タスクごとに複数のターミナルタブを持つのと同じように、複数のチャットセッションを保存し、いつでも必要なものを再開できます。
## ヒント 13: マルチディレクトリワークスペース - 1つのGemini、多数のフォルダ

**クイックユースケース:** プロジェクトが複数のリポジトリやディレクトリに分かれていますか？ Gemini CLIを、*それらすべて*へのアクセス権を持って起動できるため、統一されたワークスペースとして認識させることができます。例えば、フロントエンドとバックエンドが別々のフォルダにある場合、両方を含めることで、Geminiが両方のファイルを編集したり参照したりできるようになります。

**マルチディレクトリモード**を使用するには2つの方法があります：

* **起動フラグ:** Gemini CLIを起動するときに `--include-directories`（または `-I`）フラグを使用します。例えば：

```bash
gemini --include-directories "../backend:../frontend"
```

これは、例えば `scripts` ディレクトリからコマンドを実行し、2つの兄弟フォルダを含めたい場合を想定しています。パスのコロン区切りリストを提供します。Gemini CLIは、それらすべてのディレクトリを1つの大きなワークスペースの一部として扱います。

* **永続的な設定:** `settings.json` で `"includeDirectories": ["path1", "path2", [...]](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,61AFEF%22%2C%20%22AccentPurple)` を定義できます。これは、特定の共通ディレクトリ（複数のプロジェクトで使用する共有ライブラリフォルダなど）を常に読み込みたい場合に便利です。パスは相対パスでも絶対パスでもかきません。パス内の環境変数（`~/common-utils` など）は[許可](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=,61AFEF%22%2C%20%22AccentPurple)されています。

マルチディレクトリモードがアクティブな場合、CLIのコンテキストとツールは、含まれるすべての場所のファイルを考慮します。`> /directory show` コマンドは、現在の[ワークスペース](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=How%20to%20add%20multiple%20directories,step)にあるディレクトリをリストします。また、`/directory add [<path>](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=How%20to%20add%20multiple%20directories,step)` を使用してセッション中に動的にディレクトリを追加することもできます - そうすると、その場で読み込まれます（起動時と同様にコンテキストをスキャンする可能性があります）。

**なぜマルチディレクトリモードを使用するのか？** マイクロサービスアーキテクチャやモジュラーコードベースでは、コードの一部があるリポジトリにあり、別の部分が別のリポジトリにあることが一般的です。1つだけでGeminiを実行した場合、他のものは「見え」ません。それらを組み合わせることで、プロジェクト間の推論が可能になります。例えば、「バックエンドの新しいAPIエンドポイントに合わせてフロントエンドのAPIクライアントを更新して」と頼むと、Geminiはバックエンドフォルダを開いてAPI定義を確認し、同時にフロントエンドコードを開いてそれに応じて変更できます。マルチディレクトリがなければ、片方ずつ行い、情報を手動で持ち越さなければなりません。

**例:** `client/` と `server/` があるとします。次のように開始します：

```bash
cd client
gemini --include-directories "../server"
```

今、`gemini>` プロンプトで `> !ls` を実行すると、`client` と `server` 両方のファイルをリストできることがわかります（別々のパスとして表示されるかもしれません）。次のようにできます：

```bash
関数名を比較するために server/routes/api.py と client/src/api.js を並べて開いて。
```

AIは両方のファイルにアクセスできます。あるいは次のように言うかもしれません：

```bash
APIが変更された: エンドポイント "/users/create" は今 "/users/register" になった。バックエンドとフロントエンドの両方をそれに応じて更新して。
```

バックエンドルートにパッチを作成し、フロントエンドのフェッチ呼び出しを調整することを同時に行えます。

内部的には、Geminiはそれらのディレクトリのファイルインデックスをマージします。各ディレクトリが巨大な場合、パフォーマンス上の考慮事項があるかもしれませんが、一般的に複数の小規模〜中規模プロジェクトは問題なく処理します。チートシートには、これが事実上複数の[ルート](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%22includeDirectories%22%3A%20%5B%22..%2Fshared,98C379%22%2C%20%22AccentYellow)を持つ1つのワークスペースを作成すると記載されています。

**ヒントの中のヒント:** 常にマルチディレクトリを使用しなくても、絶対パス（`@/path/to/file`）でファイルシステム全体を参照できることを知っておいてください。ただし、マルチディレクトリでないと、Geminiはそれらを編集する権限がなかったり、積極的にコンテキストを読み込むことを知らなかったりする場合があります。マルチディレクトリはそれらを正式にスコープに含めるため、セット全体での検索やコード生成などのタスクで、すべてのファイルを認識します。

**ディレクトリの削除:** 必要に応じて、`/directory remove <path>`（または同様のコマンド）でワークスペースからディレクトリを削除できます。これはあまり一般的ではありませんが、誤って何かを含めた場合に削除できます。

要約すると、**マルチディレクトリモードはコンテキストを統一します**。ポリレポジトリプロジェクトやコードが分割されている状況では必須です。これにより、Gemini CLIはソリューション全体を開いているIDEのように振る舞います。プロユーザーとして、これはプロジェクトのどの部分もAIの手の届かない場所にないことを意味します。

## ヒント 14: AIアシスタンスでファイルを整理・クリーンアップする

**クイックユースケース:** 散らかった `Downloads` フォルダや整理されていないプロジェクトアセットにうんざりしていませんか？ Gemini CLIをスマートオーガナイザーとして採用できます。ディレクトリの概要を提供することで、ファイルを分類し、（あなたの承認を得て）サブフォルダに移動することさえできます。例えば、「私の `Downloads` をクリーンアップして：画像を `Images` フォルダに、PDFを `Documents` に移動し、一時ファイルを削除して」といった具合です。

Gemini CLIはファイル名、サイズ、さらにはファイルの内容を読み取ることができるため、ファイルの[整理](https://github.com/google-gemini/gemini-cli/discussions/7890#:~:text=We%20built%20a%20CLI%20tool,trash%20folder%20for%20manual%20deletion)について情報に基づいた決定を下すことができます。**「Janitor AI」**と呼ばれるコミュニティ作成のツールがこれを示しています：これはGemini CLI経由で実行され、ファイルを重要 vs ジャンクとして分類し、[それに応じて](https://github.com/google-gemini/gemini-cli/discussions/7890#:~:text=We%20built%20a%20CLI%20tool,trash%20folder%20for%20manual%20deletion)グループ化します。プロセスには、ディレクトリのスキャン、ファイル名とメタデータ（および必要に応じてコンテンツ）に対するGeminiの推論の使用、そしてファイルをカテゴリに移動することが含まれていました。注目すべきは、ジャンクを自動的に削除するのではなく、[レビュー](https://github.com/google-gemini/gemini-cli/discussions/7890#:~:text=organize%20files,trash%20folder%20for%20manual%20deletion)のために `Trash` フォルダに移動したことです。

Gemini CLIを使用してこのようなワークフローを手動で再現する方法は次のとおりです：

1. **ディレクトリの調査:** Geminiにリストアップと分類をさせるプロンプトを使用します。例えば：

```bash
現在のディレクトリにあるすべてのファイルをリストし、「画像」、「動画」、「ドキュメント」、「アーカイブ」、「その他」として分類して。
```

Geminiは `!ls` などを使用してファイルリストを取得し、名前/拡張子を分析してカテゴリを生成するでしょう。

1. **整理の計画:** どのように再編成したいかGeminiに尋ねさせます。例えば：

```bash
これらのファイルのための新しいフォルダ構造を提案して。タイプ別（Images, Videos, Documentsなど）に分けたい。また、重複や不要と思われるファイルも特定して。
```

AIは計画を応答するかもしれません：例：*「フォルダを作成: `Images/`, `Videos/`, `Documents/`, `Archives/`。`X.png`, `Y.jpg` を `Images/` に移動；`A.mp4` を `Videos/` に移動；など。ファイル `temp.txt` は不要に見える（たぶん一時ファイル）。」*

1. **確認をしながら移動を実行:** その後、計画を実行するように指示できます。ファイルごとに `mv` などのシェルコマンドを使用する可能性があります。これはファイルシステムを変更するため、それぞれに対して確認プロンプトが表示されます（YOLOしない限り）。移動を慎重に承認してください。完了後、ディレクトリは提案通りにきれいに整理されます。

全体を通して、Geminiの自然言語理解が鍵となります。例えば、`IMG_001.png` が画像であることや、`presentation.pdf` がドキュメントであることを、明示的に述べられなくても推論できます。さらに、（視覚機能を使用して）画像を開いて中身を見て - 例：スクリーンショット vs 写真 vs アイコンを区別して - 名前を付けたり[それに応じて](https://dev.to/therealmrmumba/7-insane-gemini-cli-tips-that-will-make-you-a-superhuman-developer-2d7h#:~:text=If%20your%20project%20folder%20is,using%20relevant%20and%20descriptive%20terms)ソートしたりすることもできます。

**コンテンツによるファイル名の変更:** 特に魔法のような使い方は、Geminiにファイルをより説明的な名前に変更させることです。Dev Communityの記事「7 Insane Gemini CLI Tips」では、Geminiが**画像をスキャンしてその[コンテンツ](https://dev.to/therealmrmumba/7-insane-gemini-cli-tips-that-will-make-you-a-superhuman-developer-2d7h#:~:text=If%20your%20project%20folder%20is,using%20relevant%20and%20descriptive%20terms)に基づいて自動的に名前を変更する**方法について説明しています。例えば、`IMG_1234.jpg` というファイルは、ログイン[画面](https://dev.to/therealmrmumba/7-insane-gemini-cli-tips-that-will-make-you-a-superhuman-developer-2d7h#:~:text=If%20your%20project%20folder%20is,using%20relevant%20and%20descriptive%20terms)のスクリーンショットだとAIが判断すれば、`login_screen.jpg` にリネームされるかもしれません。これを行うには、次のようにプロンプトを出せます：

```bash
ここの各 .png 画像について、その内容を見て、何か説明的な名前にリネームして。
```

Geminiは各画像を開き（視覚ツール経由）、説明を取得し、`mv IMG_1234.png login_screen.png` [アクション](https://dev.to/therealmrmumba/7-insane-gemini-cli-tips-that-will-make-you-a-superhuman-developer-2d7h#:~:text=If%20your%20project%20folder%20is,using%20relevant%20and%20descriptive%20terms)を提案します。これは、特にデザインや写真フォルダ内のアセット整理を劇的に改善できます。

**2パスアプローチ:** Janitor AIの議論では、2ステップのプロセスに言及していました：最初に大まかな分類（重要 vs ジャンク vs その他）、次に[グループ](https://github.com/google-gemini/gemini-cli/discussions/7890#:~:text=organize%20files,trash%20folder%20for%20manual%20deletion)の洗練です。これを模倣できます：まず削除できそうなファイル（大きなインストーラー `.dmg` ファイルや重複など）を保持するものから分けます。次に保持するものの整理に集中します。AIがジャンクとしてフラグ付けしたものは常にダブルチェックしてください。推測は常に正しいとは限らないため、手動による監視が必要です。

**安全のヒント:** AIにファイルの移動や削除を任せるときは、バックアップを用意するか、少なくとも元に戻せるように（`/restore` または独自のバックアップで）準備してください。ドライランを行うのが賢明です：Geminiに、実行せずに、整理のために実行*する予定の*コマンドを表示するように頼み、確認します。例えば：「この計画に必要な `mv` と `mkdir` コマンドをリストアップして、まだ実行しないで。」リストを確認したら、コピー＆ペーストして実行するか、Geminiに続行するように指示できます。

これはGemini CLIを「自明でない」タスクに使用する好例です - 単にコードを書くだけでなく、**AIの知能を使ったシステムの家事**を行っています。時間を節約し、混沌に少し秩序をもたらすことができます。結局のところ、開発者として私たちはガラクタ（ログ、古いスクリプト、ダウンロード）を溜め込みがちであり、AIの用務員は非常に役立ちます。

## ヒント 15: 長い会話を圧縮してコンテキスト内に収める

**クイックユースケース:** Gemini CLIと長時間チャットしていると、モデルのコンテキスト長制限に達したり、セッションが扱いにくくなったりすることがあります。`/compress` コマンドを使用してこれまでの会話を要約し、完全な履歴を簡潔な[要約](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Command%20Description%20,files)に置き換えてください。これにより、ゼロから始めることなく、より多くの議論のためのスペースが解放されます。

大規模言語モデルには固定のコンテキストウィンドウがあります（Gemini 2.5 Proのは非常に大きいですが、無限ではありません）。これを超えると、モデルは以前のメッセージを忘れ始めたり、一貫性を失ったりする可能性があります。`/compress` 機能は基本的に、重要なポイントを保持したセッションの**AI生成 tl;dr**です。

**仕組み:** `/compress` と入力すると、Gemini CLIは会話全体（システムコンテキストを除く）を取得し、要約を作成します。そして、チャット履歴を単一のシステムまたはアシスタントメッセージとしての要約に置き換え、重要な詳細を保持しつつ、分刻みの対話を削除します。圧縮が行われたことが示されます。例えば、`/compress` の後、以下のようなものが表示されるかもしれません：

--- Conversation compressed ---  
Summary of discussion: The user and assistant have been debugging a memory leak in an application. Key points: The issue is likely in `DataProcessor.js`, where objects aren't being freed. The assistant suggested adding logging and identified a possible infinite loop. The user is about to test a fix.  
--- End of summary ---

その時点から、モデルは以前に何が起こったかのコンテキストとして、その要約（および新しいメッセージ）のみを持ちます。要約が重要な情報を捉えていれば、通常はこれで十分です。

**いつ圧縮するか:** 理想的には制限に*達する*前に。セッションが長くなっている（数百回のやり取りや、コンテキスト内に大量のコードがある）ことに気づいたら、積極的に圧縮してください。チートシートには自動圧縮設定（例：コンテキストが[最大](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%22includeDirectories%22%3A%20%5B%22..%2Fshared,98C379%22%2C%20%22AccentYellow)の60%を超えたときに圧縮）について記載されています。それを有効にすると、Geminiは自動圧縮して知らせてくれるかもしれません。そうでなければ、手動の `/compress` がツールキットにあります。

**圧縮後:** 通常通り会話を続けることができます。必要に応じて、非常に長いセッションで複数回圧縮できます。そのたびに粒度は多少失われるため、理由なく頻繁に圧縮しないでください - 複雑な議論の記憶があまりにも簡潔になってしまう可能性があります。しかし、一般的にモデル自身の要約は重要な事実を保持するのがかなり上手です（そして、重要なことはいつでも自分で再確認できます）。

**コンテキストウィンドウの例:** 説明しましょう。多くのファイルを参照して大規模なコードベースを読み込み、100万トークンのコンテキスト（最大）を持ったとします。その後、プロジェクトの別の部分に移行したい場合、新しいセッションを開始する（すべての理解を失う）のではなく、圧縮することができます。要約は、コードから収集した知識（「モジュールA、B、Cを読み込んだ。Aにはこれらの関数がある... BはCとこのように相互作用する...」など）を凝縮します。これで、その知識を抽象的に保持したまま、新しいことについて質問を進めることができます。

**メモリ vs 圧縮:** 圧縮は長期メモリに保存するのではなく、会話にローカルなものであることに注意してください。*絶対に*失いたくない事実がある場合は、ヒント4（`/memory` への追加）を検討してください - メモリ内のエントリは圧縮後も生き残るからです（それらは `GEMINI.md` コンテキストにあるため、いずれにせよ再挿入されます）。圧縮は、一時的なチャットコンテンツに関するものです。

**些細な注意点:** 圧縮後、AIのスタイルがわずかに変わる可能性があります。これは事実上、要約付きの「新しい」会話を見ているからです。自己紹介し直したり、トーンを変えたりするかもしれません。「ここから続けて...（圧縮しました）」のように指示して、スムーズにすることもできます。実際には、多くの場合問題なく継続します。

要約すると（しゃれですが）、**パフォーマンスと関連性を維持するために、セッションが長くなったら `/compress` を使用してください**。これにより、Gemini CLIは会話履歴の細部ではなく、全体像に集中できます。こうすれば、AIが書いている「精神的な紙」が足りなくなることなく、長時間のデバッグセッションや広範な設計議論を行うことができます。

## ヒント 16: `!` でシェルコマンドをパススルー（ターミナルと話す）

**クイックユースケース:** Gemini CLIセッションのどの時点でも、`!` を前に付けることで実際のシェルコマンドを実行できます。例えば、gitのステータスを確認したい場合は、`!git status` と入力するだけで、[ターミナル](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Run%20a%20single%20command%3A)で実行されます。これにより、ウィンドウやコンテキストを切り替える手間が省けます - まだGemini CLIの中にいますが、基本的に「これをちょっと実行させて」と言っているのと同じです。

このヒントはGemini CLIの**シェルモード**についてです。使用方法は2つあります：

* **単一コマンド:** プロンプトの先頭に `!` を付け、その後にコマンドと引数を続けます。これにより、現在の作業ディレクトリでそのコマンドが実行され、出力が[インライン](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Run%20shell%20commands%20directly%20in,the%20CLI)で表示されます。例えば：

```bash
!ls -lh src/
```

は `src` ディレクトリ内のファイルをリストし、通常のターミナルで表示されるようなものを出力します。出力後、Geminiプロンプトが戻ってくるので、チャットを続けたり、さらにコマンドを発行したりできます。

* **永続的なシェルモード:** `!` だけを入力してEnterキーを押すと、Gemini CLIはサブモードに切り替わり、シェルプロンプト（多くの場合 `shell>` や[それに類するもの](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=)）が表示されます。これで、複数のシェルコマンドをインタラクティブに入力できます。基本的にはCLI内のミニシェルです。再び空行で `!` と入力する（または `exit`）ことでこのモードを終了します。例えば：

```bash
!
shell> pwd
/home/alice/project
shell> python --version
Python 3.x.x
shell> !
```

最後の `!` の後、通常のGeminiプロンプトに戻ります。

**なぜこれが便利なのか？** 開発はアクションと問い合わせの混合だからです。AIと何かを議論していて、何かを確認するためにコードをコンパイルしたりテストを実行したりする必要があることに気づくかもしれません。会話を離れる代わりに、素早く実行して結果をチャットに戻すことができます。実際、Gemini CLIはツールの使用の一部としてこれを頻繁に行います（例えば、テストの修正を依頼したときに自動的に `!pytest` を実行する[可能性](https://genmind.ch/posts/Howto-Supercharge-Your-Terminal-with-Gemini-CLI/#:~:text=)があります）。しかし、ユーザーとして、手動で行うための完全な制御権もあります。

**例:**

* Geminiがコードの修正を提案した後、`!npm run build` を行ってコンパイルできるか確認し、エラーがあればコピーしてGeminiに助けを求めることができます。

* `vim` や `nano` でファイルを開きたい場合、`!nano filename` で起動することもできます（ただし、Gemini CLIには独自のインターフェースがあるため、その中でインタラクティブエディタを使用するのは少し扱いにくいかもしれません - 組み込みのエディタ統合を使用するか、エディタにコピーする方が良いでしょう）。

* シェルコマンドを使用してAIのための情報を収集できます：例えば、`!grep TODO -R .` でプロジェクト内のすべてのTODOを見つけ、GeminiにそれらのTODOへの対処を依頼するなど。

* または単に環境タスクに使用します：必要に応じて `!pip install some-package` など、CLIを離れずに実行します。

**シームレスな相互作用:** かっこいいのは、会話が出力を参照できることです。例えば、`!curl http://example.com` を実行していくつかのデータを取得し、出力を確認してから、すぐにGeminiに「上記の出力をJSONとしてフォーマットして」と言うことができます - 出力はチャットに印刷されたので、AIは作業するためのコンテキストとしてそれを持っています（大きすぎない限り）。

**デフォルトシェルとしてのターミナル:** 常にコマンドに `!` を付けていることに気づいた場合は、実際にシェルモードをデフォルトで永続的にすることができます。一つの方法は、特定のツールモードでGemini CLIを起動することです（デフォルトツールの概念があります）。しかしより簡単なのは：手動コマンドをたくさん実行し、たまにしかAIと話さない予定なら、セッション開始時にシェルモード（何もない `!`）に入るだけです。その後、質問したいときはいつでもシェルモードを終了できます。AIがいつでも利用可能な通常のターミナルにGemini CLIを変えるようなものです。

**AI計画との統合:** 時々、Gemini CLI自体がシェルコマンドの実行を提案します。承認すると、実質的に `!command` と同じことを行います。それを理解していれば、いつでも介入できることがわかります。Geminiが行き詰まったり、何かを試したい場合、提案を待つ必要はありません - 自分で実行して続行できます。

要約すると、`!` **パススルー**は、*シェルタスクのためにGemini CLIを離れる必要がない*ことを意味します。AIとのチャットとシステムでのコマンド実行の境界を取り払います。プロユーザーとして、これは効率性にとって素晴らしいことです - AIとターミナルが1つの連続した環境になります。

## ヒント 17: すべてのCLIツールを潜在的なGeminiツールとして扱う

**クイックユースケース:** Gemini CLIは、問題解決の一部としてシステムにインストールされている**あらゆる**コマンドラインツールを活用できることを認識してください。AIはシェルにアクセスできるため、`cURL`、`ImageMagick`、`git`、`Docker`、その他のツールがあれば、Geminiは適切な場合にそれを呼び出すことができます。つまり、*あなたの `$PATH` 全体がAIのツールキットです*。これは、組み込みツールをはるかに超えて、できることを大幅に拡大します。

例えば、「このフォルダ内のすべてのPNG画像をWebP形式に変換して」と頼んだとします。ImageMagickの `convert` ユーティリティがインストールされていれば、Gemini CLIは次のようなものを計画するかもしれません：各[ファイル](https://genmind.ch/posts/Howto-Supercharge-Your-Terminal-with-Gemini-CLI/#:~:text=%3E%20%21for%20f%20in%20,png%7D.webp%22%3B%20done)に対して `convert` コマンドを使用するシェルループ。実際、ブログの以前の例の1つはまさにこれを示しており、ユーザーが画像のバッチ変換を促すと、Geminiは `convert` [ツール](https://genmind.ch/posts/Howto-Supercharge-Your-Terminal-with-Gemini-CLI/#:~:text=)を使用してシェルのワンライナーを実行しました。

別のシナリオ：「私のアプリをDockerにデプロイして。」 `Docker CLI` が存在すれば、AIは必要に応じて `docker build` と `docker run` のステップを呼び出すことができます。または「FFmpegを使って `video.mp4` から音声を抽出して」 - `ffmpeg` コマンドを構築できます。

このヒントはマインドセットについてです：**Geminiはプログラムされたものに限定されません**（それはすでに広範ですが）。利用可能な他のプログラムを使用して[目標](https://medium.com/google-cloud/gemini-cli-tutorial-series-part-4-built-in-tools-c591befa59ba#:~:text=In%20this%20part%2C%20we%20looked,In%20the%20next%20part%2C%20we)を達成する方法を見つけ出すことができます。一般的な構文を知っており、必要に応じてヘルプテキストを読むことができます（ツールの `--help` を呼び出すことができます）。唯一の制限は安全性です：デフォルトでは、思いついた `run_shell_command` に対して確認を求めます。しかし、慣れてくれば、特定の無害なコマンドを自動的に許可することもできます（YOLOまたは許可ツール設定を参照）。

**環境に注意を払う:** 「大いなる力には大いなる責任が伴う。」 すべてのシェルツールが対象となるため、`$PATH` にAIに誤って実行させたくないものが含まれていないことを確認する必要があります。ここでヒント19（カスタムPATH）が登場します - 一部のユーザーはGemini用に制限された `$PATH` を作成し、例えば、破壊的なシステムコマンドを直接呼び出せないようにしたり、再帰的に `gemini` を呼び出さないように（ループを避けるため）したりしています。要点は、デフォルトで `gcc` や `terraform` などが `$PATH` にあれば、Geminiはそれを呼び出す可能性があるということです。ランダムにそうするという意味ではありません - タスクがそれを必要とする場合のみですが - しかし可能性はあります。

**思考プロセスの例:** Gemini CLIに次のように尋ねたとします：「現在のディレクトリを提供する基本的なHTTPサーバーをセットアップして。」 AIは考えるかもしれません：「Pythonの組み込みサーバーが使える。」 そして `!python3 -m http.server 8000` を発行します。これで、システムツール（Python）を使用してサーバーを起動しました。これは無害な例です。他には：「このLinuxシステムのメモリ使用量を確認して。」 AIは `free -h` コマンドを使用するか、`/proc/meminfo` から読み取るかもしれません。利用可能なコマンドを使用することで、システム管理者が行うことを効果的に行っています。

**すべてのツールはAIの拡張です:** これはやや未来的ですが、あらゆるコマンドラインプログラムは、AIが機能を拡張するために呼び出すことができる「関数」と見なすことができると考えてください。数学の問題を解く必要がありますか？ `bc`（電卓）を呼び出すことができます。画像を操作する必要がありますか？ 画像処理ツールを呼び出すことができます。データベースをクエリする必要がありますか？ CLIクライアントがインストールされており、資格情報があれば、それを使用できます。可能性は広大です。他のAIエージェントフレームワークでは、これはツール使用として知られており、Gemini CLIは正しい[ツール](https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-deep-dive-into-gemini-cli-with-taylor-mullen#:~:text=The%20Gemini%20CLI%20%20is,understanding%20of%20the%20developer%20workflow)を決定するためにそのエージェントに多くの信頼を置いて設計されています。

**うまくいかないとき:** 裏を返せば、AIがツールを誤解したり、ツールについて幻覚を見たりした場合です。存在しないコマンドを呼び出そうとしたり、間違ったフラグを使用したりして、エラーになる可能性があります。これは大したことではありません - エラーが表示され、修正または明確化できます。実際、Gemini CLIのシステムプロンプトは、盲目的に実行するのではなく、まずドライランを行う（コマンドを提案するだけ）ようにガイドしている可能性があります。そのため、これらをキャッチする機会がよくあります。開発者は、これらのミスを減らすためにツール選択ロジックを改善し続けています。

主なポイントは、**Gemini CLIを非常に大きなスイスアーミーナイフを持っていると考えること**です - 組み込みのブレードだけでなく、OSにあるすべてのツールです。標準的なものであれば、使い方を教える必要はありません。通常、知っているか調べることができます。これにより、達成できることが*指数関数的*に増幅されます。インストールされているほぼすべてのプログラムの実行方法を知っているジュニア開発者やDevOpsエンジニアがいるようなものです。

プロユーザーとして、Geminiにより多くの力を与えるために、追加のCLIツールを特別にインストールすることさえできます。例えば、クラウドサービス用のCLI（AWS CLI、GCloud CLIなど）をインストールすれば、理論上、Geminiはプロンプトがあればクラウドリソースを管理するためにそれを利用できます。強力なツールを使用する場合は特に、実行されるコマンドを理解し信頼することを確認してください（誤って巨大なクラウドインスタンスを立ち上げさせたくないでしょう）。しかし、賢く使えば、この概念 - **すべてがGeminiツール** - は、環境に統合するにつれて *指数関数的* に能力を高めるものです。

## ヒント 18: マルチモーダルAIを活用する - Geminiに画像などを見せる

**クイックユースケース:** Gemini CLIはテキストに限定されません - マルチモーダルです。つまり、画像、図、あるいは与えられればPDFさえも分析できます。これを活用してください。例えば、「エラーダイアログのスクリーンショットです、`@./error.png` - トラブルシューティングを手伝って」と言うことができます。AIは画像を「見て」、それに応じて応答します。

GoogleのGeminiモデル（およびCodey形式の前身であるPaLM2）の際立った機能の1つは画像理解です。Gemini CLIでは、`@` で画像を参照すると、モデルは画像データを受け取ります。画像の内容について説明、分類、または推論を出力できます。コンテンツによる画像のリネーム（ヒント14）やスクリーンショットの説明（ヒント7）についてはすでに説明しました。しかし、他の創造的な用途を考えてみましょう：

* **UI/UXフィードバック:** デザイナーと協力している開発者の場合、UI画像をドロップして、Geminiにフィードバックやコード生成を依頼できます。「このUIモックアップ `@mockup.png` を見て、そのためのReactコンポーネント構造を作成して。」 画像内の要素（ヘッダー、ボタンなど）を特定し、コードの概要を示すことができます。

* **画像の整理:** リネームだけでなく、混合画像のフォルダがあり、テーマ別に並べ替えたい場合があります。「`./photos/` 内の画像をテーマ（夕日、山、人々など）ごとにサブフォルダに並べ替えて。」 AIは各写真を見て分類できます（これは一部の写真アプリがAIで行っていることと似ています - 今やGeminiを介して自分のスクリプトで実行できます）。

* **OCRとデータ抽出:** エラーテキストのスクリーンショットやドキュメントの写真がある場合、Geminiは多くの場合そこからテキストを読み取ることができます。例えば、「`invoice.png` からテキストを抽出し、構造化された形式にして。」 Google Cloudのブログの例で示されているように、Gemini CLIは請求書画像のセットを処理し、その[情報](https://medium.com/google-cloud/gemini-cli-tutorial-series-part-4-built-in-tools-c591befa59ba#:~:text=Press%20enter%20or%20click%20to,view%20image%20in%20full%20size)のテーブルを出力できます。基本的には、請求書の写真から請求書番号、日付、金額を取得するためにOCR + 理解を行いました。これは高度なユースケースですが、内部のマルチモーダルモデルであれば完全に可能です。

* **グラフやチャートの理解:** グラフのスクリーンショットがある場合、「このチャートの重要な洞察を説明して `@chart.png`」と尋ねることができます。軸や傾向を解釈するかもしれません。精度は異なる場合がありますが、気の利いた試みです。

これを実用的にするために：`@image.png` を使用するときは、画像が大きすぎないことを確認してください（モデルは適度に大きな画像を処理できますが）。CLIはおそらくそれをエンコードしてモデルに送信します。応答には説明やさらなるアクションが含まれる場合があります。1つのプロンプトでテキストと画像参照を混在させることもできます。

**画像以外のモダリティ:** CLIとモデルは、ツールを介して変換することで、潜在的にPDFや音声も処理できる可能性があります。例えば、`@report.pdf` すると、Gemini CLIは内部でPDF-to-textツールを使用してテキストを抽出し、要約するかもしれません。`@audio.mp3` して書き起こしを求めると、音声テキスト変換ツール（音声認識機能のようなもの）を使用するかもしれません。チートシートは、PDF、音声、ビデオファイルの参照が[サポート](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Reference%20files%20or%20directories%20in,PDFs%2C%20audio%2C%20and%20video%20files)されていることを示唆しており、おそらく適切な内部ツールまたはAPIを呼び出すことによって行われます。したがって、「このインタビュー音声を書き起こして: `@interview.wav`」は実際に機能する可能性があります（今でなくとも、音声テキスト変換のための基盤となるGoogle APIがプラグインされる可能性があるため、近いうちに）。

**リッチな出力:** マルチモーダルは、統合されている場合（CLIでは通常直接表示しませんが、画像ファイルを保存したり、ASCIIアートを出力したりするなど）、AIが応答で画像を返すことができることも意味します。MCP機能では、ツールが[画像](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Capabilities%3A)を返すことができると言及しました。例えば、AI描画ツールが画像を生成し、Gemini CLIがそれを提示する（開くかリンクを与えるかして）ことが可能です。

**重要:** CLI自体はテキストベースなので、ターミナルで画像を*見る*ことはありません（ASCIIプレビューなどが可能でない限り）。分析を得るだけです。したがって、これは主に画像を表示するのではなく、読み取ることに関するものです。VS Code統合を使用している場合は、チャットビューに画像が表示されるかもしれません。

要約すると、**Gemini CLIを使用するときはGUIの「I（インターフェース）」を忘れないでください** - 多くの場合、テキストと同様に視覚も扱えます。これにより、同じツールの下で、視覚的なデバッグ、デザイン支援、スクリーンショットからのデータ抽出などのワークフローが開かれます。これは、他のCLIツールにはまだないかもしれない差別化要因です。そしてモデルが改善するにつれて、このマルチモーダルサポートはより強力になるだけなので、活用すべき将来性のあるスキルです。

## ヒント 19: 安定性のために `$PATH`（およびツールの可用性）をカスタマイズする

**クイックユースケース:** Gemini CLIが混乱したり、間違ったプログラムを呼び出したりすることに気づいたら、調整された `$PATH` で実行することを検討してください。利用可能な実行ファイルを制限または順序付けすることで、例えば、意図しない同様の名前のスクリプトをAIが呼び出すのを防ぐことができます。基本的に、既知の優れたツールへのツールアクセスをサンドボックス化します。

ほとんどのユーザーにとってこれは問題ではありませんが、多数のカスタムスクリプトや複数のバージョンのツールを持つプロユーザーにとっては役立ちます。開発者が挙げた理由の1つは、無限ループや奇妙な[動作](https://github.com/google-gemini/gemini-cli/discussions/7890#:~:text=We%20built%20a%20CLI%20tool,trash%20folder%20for%20manual%20deletion)を避けることです。例えば、`gemini` 自体が `$PATH` にある場合、暴走したAIがGeminiの中から再帰的に `gemini` を呼び出す可能性があります（奇妙なシナリオですが、理論的には可能です）。あるいは、何かと競合する `test` という名前のコマンドがある場合、AIは間違った方を呼び出すかもしれません。

**Gemini用のPATHの設定方法:** 最も簡単なのは起動時にインラインで指定することです：

```bash
PATH=/usr/bin:/usr/local/bin gemini
```

これは、それらのディレクトリだけの制限された `$PATH` でGemini CLIを実行します。実験的または危険なスクリプトがあるディレクトリを除外するかもしれません。あるいは、`$PATH` をパージまたは調整してから `gemini` をexecする小さなシェルスクリプトラッパーを作成します。

もう一つのアプローチは、環境変数または設定を使用して特定のツールを明示的に無効にすることです。例えば、AIに `rm` や何らかの破壊的なツールを絶対に使用させたくない場合、技術的には何もしないエイリアスやダミーの `rm` を安全な `$PATH` に作成できます（ただし、これは通常の操作に干渉する可能性があるため、あまり推奨されません）。より良い方法は、設定の**除外リスト**です。拡張機能または `settings.json` で、ツール[名](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=)を除外できます。例：

```json
"excludeTools": ["run_shell_command"]
```

この極端な例は、*すべての*シェルコマンドの実行を停止します（Geminiを実質的に読み取り専用にします）。もっと細かく、一部の確認をスキップすることについて言及しました；同様に、次のような構成ができるかもしれません：

```json
"tools": {
  "exclude": ["apt-get", "shutdown"]
}
```

*（この構文は説明用です；正確な使用法についてはドキュメントを参照してください。）*

原則として、環境を制御することで、AIが本来すべきでないツールで愚かなことをするリスクを減らします。家を子供向けに安全にするようなものです。

**無限ループを防ぐ:** あるユーザーのシナリオでは、Geminiが自分の出力を読み続けたり、ファイルを再読み込みし続けたりするループがありました[繰り返し](https://support.google.com/gemini/thread/337650803/infinite-loops-with-tool-code-in-answers?hl=en#:~:text=Community%20support,screen%20with%20weird%20scrolling)。カスタム `$PATH` はロジックループを直接修正することはできませんが、原因の1つは、AIが自分自身をトリガーするコマンドを呼び出すことにあるかもしれません。誤って別のAIインスタンス（`bard` や `gemini` コマンドを呼び出すなど、そうしようと考えた場合）を生成できないようにすることは良いことです。`$PATH` からそれらを削除する（またはそのセッション用にリネームする）ことは役立ちます。

**サンドボックスによる隔離:** `$PATH` をいじる代わりのもう一つの方法は、`--sandbox` モード（隔離された[環境](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=echo%20,gemini)でツールを実行するためにDockerまたはPodmanを使用する）を使用することです。その場合、AIのアクションは封じ込められ、サンドボックスイメージが提供するツールのみを持ちます。キュレーションされたツールセットを持つDockerイメージを提供できます。これは強引ですが非常に安全です。

**特定のタスク用のカスタムPATH:** プロジェクトごとに異なる `$PATH` セットアップを持つ場合があります。例えば、あるプロジェクトでは特定のバージョンのNodeやローカルツールチェーンを使用させたいとします。そのバージョンを指す `$PATH` で `gemini` を起動すれば、AIが正しいものを使用することが保証されます。基本的に、Gemini CLIを他のユーザーと同じように扱ってください - 与えられた環境を使用します。したがって、`gcc-10` vs `gcc-12` を選ばせる必要がある場合は、それに応じて `$PATH` や `CC` 環境変数を調整してください。

**要約すると:** *ガードレール*です。パワーユーザーとして、AIの動作条件を微調整する能力があります。ツールの使用に関連する望ましくない動作のパターンを見つけた場合、`$PATH` の調整は素早い救済策です。日常の使用では、これが必要になることはおそらくありませんが、Gemini CLIを自動化やCIに統合する場合に覚えておくべきプロのヒントです：制御された環境を与えてください。そうすれば、何ができて何ができないかを正確に把握でき、信頼性が向上します。

---

## ヒント 20: トークンキャッシュと統計でトークン消費を追跡・削減する

長いチャットを実行したり、同じ大きなファイルを繰り返し添付したりする場合、トークンキャッシュをオンにして使用状況を監視することで、コストとレイテンシを削減できます。APIキーまたはVertex AI認証を使用すると、Gemini CLIは以前に送信されたシステム指示とコンテキストを自動的に再利用するため、フォローアップリクエストはより安価になります。CLIで削減状況をリアルタイムで確認できます。

**使用方法**

キャッシュを有効にする認証モードを使用します。トークンキャッシュは、Gemini APIキーまたはVertex AIで認証する場合に利用可能です。現在、OAuthログインでは利用できません。[Google Gemini](https://google-gemini.github.io/gemini-cli/docs/cli/token-caching.html)

使用状況とキャッシュヒットを検査します。セッション中に `stats` コマンドを実行します。キャッシュがアクティブな場合、合計トークンと `cached` フィールドが表示されます。

```bash
/stats
```

コマンドの説明とキャッシュレポートの動作は、コマンドリファレンスとFAQに記載されています。[Google Gemini+1](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html?utm_source=chatgpt.com)

スクリプトでメトリクスをキャプチャします。ヘッドレスで実行する場合、JSONを出力し、各モデルの `tokens.cached` を含む `stats` ブロックを解析します：

```bash
gemini -p "READMEを要約して" --output-format json
```

ヘッドレスガイドには、キャッシュトークン数を含むJSONスキーマが記載されています。[Google Gemini](https://google-gemini.github.io/gemini-cli/docs/cli/headless.html)

セッション要約をファイルに保存する: CIや予算追跡のために、JSONセッション要約をディスクに書き込みます。

```bash
gemini -p "ログを分析して" --session-summary usage.json
```

このフラグは変更履歴に記載されています。[Google Gemini](https://google-gemini.github.io/gemini-cli/docs/changelogs/)

APIキーまたはVertex認証を使用すると、CLIは以前に送信されたコンテキストを自動的に再利用するため、後のターンでは送信するトークンが少なくなります。`GEMINI.md` や大きなファイル参照をターン間で安定させておくとキャッシュヒットが増えます；統計にキャッシュトークンとして反映されるのがわかります。
## ヒント 21: 素早いクリップボードコピーに `/copy` を使用する

**クイックユースケース:** 余計なフォーマットや行[番号](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,for%20easy%20sharing%20or%20reuse)なしで、Gemini CLIからの最新の回答やコードスニペットをシステムクリップボードに即座にコピーします。これは、AI生成コードをエディタに素早く貼り付けたり、結果をチームメイトと共有したりするのに最適です。

Gemini CLIが回答（特に複数行のコードブロック）を提供すると、それを他の場所で再利用したいことがよくあります。`/copy` スラッシュコマンドは、*CLIによって生成された最後の出力*を[クリップボード](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,for%20easy%20sharing%20or%20reuse)に直接コピーすることで、これを簡単に行えるようにします。手動選択（行番号やプロンプトテキストが含まれてしまうことがある）とは異なり、`/copy` は生の応答コンテンツのみを取得します。例えば、Geminiが50行のPythonスクリプトを生成した場合、`/copy` と入力するだけで、スクロールしてテキストを選択する必要なく、そのスクリプト全体がクリップボードに入り、貼り付けの準備が整います。内部的には、Gemini CLIはプラットフォームに適したクリップボードユーティリティ（macOSでは `pbcopy`、[Windows](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,clip)では `clip`）を使用します。コマンドを実行すると、通常は確認メッセージが表示され、その後、必要な場所にコピーしたテキストを貼り付けることができます。

**仕組み:** `/copy` コマンドには、システムにクリップボードツールが[利用可能](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,clip)である必要があります。macOSとWindowsでは、必要なツール（それぞれ `pbcopy` と `clip`）は通常プリインストールされています。Linuxでは、`/copy` が[機能](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,clip)するために `xclip` または `xsel` をインストールする必要がある場合があります。それを確認したら、Gemini CLIが回答を出力した後はいつでも `/copy` を使用できます。これは（たとえ長くても）*直近*の応答全体をキャプチャし、CLIが画面上に表示する可能性のある内部番号付けやフォーマットを省略します。これにより、コンテンツを転送する際に不要なアーティファクトに対処する手間が省けます。小さな機能ですが、コードを反復したり、AIによって生成されたレポートをまとめたりするときには、大幅な時間の節約になります。

**プロのヒント:** `/copy` コマンドが機能していないことがわかった場合は、クリップボードユーティリティがインストールされ、アクセス可能であることを再確認してください。例えば、Ubuntuユーザーはクリップボード[コピー](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,clip)を有効にするために `sudo apt install xclip` を実行する必要があります。セットアップが完了すれば、`/copy` でGeminiの出力を摩擦ゼロで共有できます - コピーして貼り付ければ完了です。

## ヒント 22: シェルモードと終了のために `Ctrl+C` をマスターする

**クイックユースケース:** **Ctrl+C** [ショートカット](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Shortcut%20Description%20,Press%20twice%20to%20confirm)のおかげで、1回のキー押下でGemini CLIをきれいに中断したりシェルモードを終了したりできます - そして素早いダブルタップでCLIを完全に終了できます。これにより、停止や終了が必要なときに即座に制御できます。

Gemini CLIはREPLのように動作し、操作から抜け出す方法を知ることは不可欠です。**Ctrl+C** を1回押すと、現在のアクションをキャンセルするか、入力し始めた入力をクリアし、基本的に「中止」[コマンド](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Shortcut%20Description%20,Press%20twice%20to%20confirm)として機能します。例えば、AIが長い回答を生成していて十分見た場合は、`Ctrl+C` を押すと生成は即座に停止します。プロンプトを入力し始めたが破棄したい場合、`Ctrl+C` は入力行を消去して[最初](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Shortcut%20Description%20,Press%20twice%20to%20confirm)からやり直せるようにします。さらに、**シェルモード**（シェルコマンドを実行するために `!` と入力してアクティブ化）にいる場合、 `Ctrl+C` を1回押すとシェルモードを終了して通常のGeminiプロンプトに戻ります（[実行中](https://milvus.io/ai-quick-reference/how-do-i-use-gemini-cli-for-shell-command-generation#:~:text=The%20shell%20integration%20also%20includes,where%20you%20can%20generate%20commands)のシェルプロセスに割り込みを送信します）。これは、シェルコマンドがハングしている場合や、単にAIモードに戻りたい場合に非常に便利です。

**Ctrl+Cを2回連続**で押すことは、Gemini CLIを[完全に](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Shortcut%20Description%20,Press%20twice%20to%20confirm)終了するためのショートカットです。「`Ctrl+C` でキャンセル、もう一度 `Ctrl+C` で終了」と考えてください。このダブルタップは、セッションを終了するようCLIに合図します（さよならメッセージが表示されるか、プログラムが閉じます）。これは `/quit` と入力したりターミナルウィンドウを閉じたりするよりも速い代替手段であり、キーボードからCLIを優雅にシャットダウンできます。クリアすべき入力や中断すべき操作がある場合、単一の `Ctrl+C` では終了しないことに注意してください - 完全に[終了](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Shortcut%20Description%20,Press%20twice%20to%20confirm)するには、その2回目の押下（プロンプトがアイドルのとき）が必要です。この設計は、現在の出力を停止しようとしただけのときに誤ってセッションを閉じてしまうのを防ぎます。

**プロのヒント:** シェルモードでは、**Esc** キーを押してシェルモードを終了し、[CLI](https://milvus.io/ai-quick-reference/how-do-i-use-gemini-cli-for-shell-command-generation#:~:text=The%20shell%20integration%20also%20includes,where%20you%20can%20generate%20commands)を終了せずにGeminiのチャットモードに戻ることもできます。また、より正式な終了を好む場合は、セッションをきれいに終了するための `/quit` コマンドが常に利用可能です。最後に、Unixユーザーは空のプロンプトで **Ctrl+D** (EOF) を使用して終了することもできます - [必要](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Shortcut%20Description%20,Press%20twice%20to%20confirm)であればGemini CLIは確認を求めます。しかしほとんどの場合、 `Ctrl+C` のシングルタップとダブルタップをマスターすることが、コントロールを維持するための最速の方法です。

## ヒント 23: `settings.json` でGemini CLIをカスタマイズする

**クイックユースケース:** ワンサイズフィットオールの[デフォルト](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%2A%20%60autoAccept%60%3A%20Auto,to%20disable%20usage%20statistics)に固執する代わりに、`settings.json` 設定ファイルを編集して、CLIの動作と外観を好みやプロジェクトの慣習に適応させます。これにより、テーマ、ツールの使用ルール、エディタモードなどをすべてのセッションで強制できます。

Gemini CLIは高度に設定可能です。ホームディレクトリ（`~/.gemini/`）またはプロジェクトフォルダ（リポジトリ内の `.gemini/`）に `settings.json` ファイルを作成して、デフォルトの[設定](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Customize%20the%20CLI%20by%20creating,applied%20with%20the%20following%20precedence)をオーバーライドできます。視覚的なテーマからツールの権限まで、CLIのほぼすべての側面をここで調整できます。CLIは、システム全体のデフォルト、ユーザー設定、およびプロジェクト固有の設定（プロジェクト設定はユーザー[設定](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Customize%20the%20CLI%20by%20creating,applied%20with%20the%20following%20precedence)をオーバーライドします）の複数のレベルから設定をマージします。例えば、ダークテーマをグローバルに好むかもしれませんが、特定のプロジェクトではより厳密なツールサンドボックスが必要な場合があります。これは、各レベルで異なる `settings.json` ファイルを使用して処理できます。

`settings.json` 内では、オプションはJSONのキーと値のペアとして指定されます。以下はいくつかの有用なカスタマイズを示すスニペットです：

```json
{
"theme": "GitHub",
"autoAccept": false,
"vimMode": true,
"sandbox": "docker",
"includeDirectories": ["../shared-library", "~/common-utils"],
"usageStatisticsEnabled": true
}
```

この例では、テーマを「GitHub」（人気のある配色）に設定し、`autoAccept` を無効にし（変更を加える可能性のあるツールを実行する前にCLIが常に確認するようにし）、入力エディタにVimキーバインディングを有効にし、ツールサンドボックスにDockerの使用を強制しています。また、`includeDirectories` にいくつかのディレクトリを追加して、Geminiが[デフォルト](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%7B%20,utils)で共有パス内のコードを見られるようにしました。最後に、`usageStatisticsEnabled` をtrueのままにして、基本的な使用統計を収集するようにしました（[有効](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%2A%20%60autoAccept%60%3A%20Auto,to%20disable%20usage%20statistics)な場合、テレメトリに供給されます）。他にも多くの設定があります - カスタムカラーテーマの定義、トークン制限の調整、特定のツールのホワイトリスト/ブラックリスト化など - すべて構成[ガイド](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=%2A%20%60autoAccept%60%3A%20Auto,to%20disable%20usage%20statistics)に記載されています。これらを調整することで、Gemini CLIが*あなたの*ワークフローに最適に振る舞うことを保証します（例えば、効率のために常に `vimMode` をオンにしたい開発者もいれば、デフォルトのエディタを好む人もいるでしょう）。

設定を編集する便利な方法の1つは、組み込みの設定UIを使用することです。Gemini CLIで `/settings` コマンドを実行すると、[構成](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,their%20current%20values%2C%20and%20modify)のためのインタラクティブエディタが開きます。このインターフェースでは、説明付きで設定を閲覧および検索でき、入力を検証することでJSON構文エラーを防ぎます。フレンドリーな[メニュー](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,their%20current%20values%2C%20and%20modify)を通じて、色を微調整したり、`yolo`（自動承認）のような機能を切り替えたり、チェックポイント（ファイルの保存/復元動作）を調整したりできます。変更は `settings.json` に保存され、一部はすぐに有効になります（CLIの再起動が必要な場合もあります）。

**プロのヒント:** 異なるニーズのために、プロジェクト固有の `settings.json` ファイルを分けて維持してください。例えば、チームプロジェクトでは `"sandbox": "docker"` と `"excludeTools": ["run_shell_command"]` を設定して危険な操作をロックダウンしつつ、個人プロジェクトでは直接のシェルコマンドを許可するかもしれません。Gemini CLIは自動的にプロジェクトディレクトリツリー内の最も近い `.gemini/settings.json` を拾い上げ、グローバルの [`~/.gemini/settings.json`](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Customize%20the%20CLI%20by%20creating,applied%20with%20the%20following%20precedence) とマージします。また、視覚的な好みを素早く調整できることを忘れないでください：ファイルを編集せずにテーマをインタラクティブに切り替えるには `/theme` を試してください。これは快適な[外観](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Command%20Description%20,tag%3E%60Save%20the%20current%20conversation)を見つけるのに最適です。見つけたら、それを `settings.json` に入れて永続化してください。

## ヒント 24: コンテキストとDiffのためにIDE統合（VS Code）を活用する

**クイックユースケース:** VS CodeにフックすることでGemini CLIをスーパーチャージします - CLIはあなたが作業しているファイルを知り、AIが提案したコード変更をVS Codeの差分エディタで自動的に開いて[くれます](https://developers.googleblog.com/en/gemini-cli-vs-code-native-diffing-context-aware-workflows/?source=post_page-----26afd3422028---------------------------------------#:~:text=,working%20on%20at%20the%20moment)。これにより、AIアシスタントとコーディングワークスペースの間にシームレスなループが生まれます。

Gemini CLIの強力な機能の1つは、Visual Studio Codeとの**IDE統合**です。VS Codeに公式の *Gemini CLI Companion* 拡張機能をインストールして接続することで、Gemini CLIがあなたの[エディタ](https://developers.googleblog.com/en/gemini-cli-vs-code-native-diffing-context-aware-workflows/?source=post_page-----26afd3422028---------------------------------------#:~:text=,working%20on%20at%20the%20moment)を「コンテキスト認識」できるようになります。実際にはどういう意味でしょうか？ 接続されると、Geminiは開いているファイル、現在のカーソル位置、VS [Code](https://developers.googleblog.com/en/gemini-cli-vs-code-native-diffing-context-aware-workflows/?source=post_page-----26afd3422028---------------------------------------#:~:text=,working%20on%20at%20the%20moment)で選択したテキストを知ります。そのすべての情報がAIのコンテキストに供給されます。したがって、「この関数を説明して」と尋ねると、プロンプトにコードをコピー＆ペーストする必要なく、Gemini CLIはハイライトした正確な関数を見て、関連する回答を与えることができます。統合は最大10個の最近開いたファイルと、選択およびカーソル情報を共有し、モデルに[ワークスペース](https://gemini-cli.xyz/docs/en/ide-integration#:~:text=,reject%20the%20suggested%20changes%20seamlessly)のリッチな理解を与えます。

もう1つの大きな利点は、コード変更の**ネイティブな差分**です。Gemini CLIがコードの修正を提案するとき（例えば、「この関数をリファクタリングして」と言ってパッチを作成するとき）、それらの変更をVS Codeの差分ビューアで[自動的に](https://developers.googleblog.com/en/gemini-cli-vs-code-native-diffing-context-aware-workflows/?source=post_page-----26afd3422028---------------------------------------#:~:text=%2A%20Native%20in,the%20code%20right%20within%20this)開くことができます。VS Codeで提案された編集を示すサイドバイサイドの差分が表示されます。その後、VS Codeの使い慣れたインターフェースを使用して変更をレビューし、手動で調整し、クリックしてパッチを受け入れることもできます。CLIとエディタは同期を保ちます - VS Codeで差分を受け入れると、Gemini CLIはそれを認識し、それらの変更が適用された状態でセッションを続行します。この緊密なループにより、ターミナルからエディタにコードをコピーする必要がなくなります。AIの提案は開発環境に直接流れ込みます。

**設定方法:** VS Codeの統合ターミナル内でGemini CLIを起動すると、VS Codeを検出し、通常は拡張機能のインストール/接続を[自動的に](https://medium.com/google-cloud/gemini-cli-tutorial-series-part-10-gemini-cli-vs-code-integration-26afd3422028#:~:text=Press%20enter%20or%20click%20to,view%20image%20in%20full%20size)求めます。同意すると、必要な `/ide install` ステップを実行します。プロンプトが表示されない場合（または後で有効にする場合）は、Gemini CLIを開いて `/ide install` コマンドを実行してください。これにより、"Gemini CLI Companion" 拡張機能が[フェッチ](https://developers.googleblog.com/en/gemini-cli-vs-code-native-diffing-context-aware-workflows/?source=post_page-----26afd3422028---------------------------------------#:~:text=2%3A%20One,install%20the%20necessary%20companion%20extension)されインストールされます。次に、`/ide enable` を実行して[接続](https://developers.googleblog.com/en/gemini-cli-vs-code-native-diffing-context-aware-workflows/?source=post_page-----26afd3422028---------------------------------------#:~:text=3%3A%20Toggle%20integration%3A%20After%20the,can%20easily%20manage%20the%20integration)を確立します - これでCLIはVS Codeにリンクされていることを示します。いつでも `/ide status` で検証でき、接続されているかどうか、およびどのエディタとファイルが[追跡](https://gemini-cli.xyz/docs/en/ide-integration#:~:text=Checking%20the%20Status)されているかが表示されます。それ以降、Gemini CLIは自動的にVS Codeからコンテキストを受け取り（ファイルを開く、選択）、必要なときにVS Codeで差分を開きます。これは本質的にGemini CLIを、ターミナル内に住んでいるがあなたのIDEを完全に認識して動作するAIペアプログラマーに変えます。

現在、VS Codeはこの[統合](https://gemini-cli.xyz/docs/en/ide-integration#:~:text=better%20and%20enables%20powerful%20features,editor%20diffing)でサポートされている主要なエディタです。（VSCodiumや、プラグイン経由の一部のJetBrainsのような、VS Code拡張機能をサポートする他のエディタも、同じ拡張機能経由で動作する可能性がありますが、公式には今のところVS Codeです。）ただし設計はオープンです - 他の[エディタ](https://gemini-cli.xyz/docs/en/ide-integration#:~:text=better%20and%20enables%20powerful%20features,editor%20diffing)と同様の統合を開発するためのIDE Companion Specがあります。将来的には、コミュニティ拡張機能を介してIntelliJやVimのようなIDEに対するファーストクラスのサポートが見られるかもしれません。

**プロのヒント:** 接続したら、VS Codeのコマンドパレットを使用して、[エディタ](https://gemini-cli.xyz/docs/en/ide-integration#:~:text=,Ctrl%2BShift%2BP)を離れることなくGemini CLIを制御できます。例えば、**Ctrl+Shift+P**（MacではCmd+Shift+P）を押して、**"Gemini CLI: Run"**（ターミナルで新しいCLIセッションを起動）、**"Gemini CLI: Accept Diff"**（開いている差分を承認して適用）、または **"Gemini CLI: Close Diff Editor"**（[変更](https://gemini-cli.xyz/docs/en/ide-integration#:~:text=,Ctrl%2BShift%2BP)を拒否）のようなコマンドを試してください。これらのショートカットにより、ワークフローをさらに効率化できます。そして覚えておいてください、CLIを常に手動で起動する必要はありません - 統合を有効にすれば、Gemini CLIは実質的にVS Code内のAI共同開発者となり、コンテキストを監視し、コード作業中にいつでも助ける準備ができています。

## ヒント 25: `Gemini CLI GitHub Action` でリポジトリタスクを自動化する

**クイックユースケース:** GitHubでGeminiを働かせましょう - **Gemini CLI GitHub Action**を使用して、リポジトリ内の新しいIssueのトリアージやプルリクエストのレビューを自律的に行い、ルーチン開発[タスク](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=1,write%20tests%20for%20this)を処理するAIチームメイトとして振る舞わせます。

Gemini CLIはインタラクティブなターミナルセッションだけのものではありません。GitHub Actions経由でCI/CDパイプラインでも実行できます。Googleは、リポジトリの[ワークフロー](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=It%E2%80%99s%20now%20in%20beta%2C%20available,cli)に統合する既製の**Gemini CLI GitHub Action**（現在ベータ版）を提供しています。これは効果的にAIエージェントをGitHub上のプロジェクトにデプロイします。リポジトリの[イベント](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=Triggered%20by%20events%20like%20new,do%2C%20and%20gets%20it%20done)によってトリガーされ、バックグラウンドで実行されます。例えば、誰かが**新しいIssue**を開くと、Gemini Actionは自動的にIssueの説明を分析し、関連するラベルを適用し、優先順位を付けたり重複を提案したりすることさえできます（これが「インテリジェントIssueトリアージ」[ワークフロー](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=1,attention%20on%20what%20matters%20most)です。**プルリクエスト**が開かれると、Actionが起動して**AIコードレビュー**を提供します - コード品質、潜在的なバグ、またはスタイル上の[改善](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=attention%20on%20what%20matters%20most,more%20complex%20tasks%20and%20decisions)についての洞察をPRにコメントします。これにより、人間が見る前にメンテナーにPRに関する即時のフィードバックが提供されます。おそらく最もクールな機能は**オンデマンドコラボレーション**です：チームメンバーはIssueやPRコメントで `@gemini-cli` にメンションして、「`@gemini-cli` これのユニットテストを書いて」のような指示を与えることができます。Actionはそれを拾い上げ、Gemini CLIはリクエストを満たそうとします（例えば、新しいテストを含むコミットを[追加](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=freeing%20up%20reviewers%20to%20focus,write%20tests%20for%20this)する）。リポジトリに住んでいて、頼まれれば雑用をこなす準備ができているAIアシスタントがいるようなものです。

Gemini CLI GitHub Actionのセットアップは簡単です。まず、ローカルにGemini CLIバージョン **0.1.18以降** がインストールされていることを確認します（これにより[Action](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=Gemini%20CLI%20GitHub%20Actions%20is,for%20individual%20users%20available%20soon)との互換性が確保されます）。次に、Gemini CLIで特別なコマンド：[`/setup-github`](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=To%20get%20started%2C%20download%20Gemini,cli) を実行します。このコマンドは、リポジトリに必要なワークフローファイルを生成します（必要に応じて認証をガイドします）。具体的には、`.github/workflows/` 下にYAMLワークフローファイル（Issueトリアージ、PRレビュー用など）を追加します。ActionがGemini [API](https://github.com/google-github-actions/run-gemini-cli#:~:text=Store%20your%20API%20key%20as,in%20your%20repository)を使用できるように、Gemini APIキーをリポジトリのシークレット（`GEMINI_API_KEY` として）に追加する必要があります。それが完了してワークフローがコミットされると、GitHub Actionが動き出します - その時点から、Gemini CLIはそれらのワークフローに従って新しいIssueやPRに自律的に応答します。

このActionは基本的に自動化された方法でGemini CLIを実行しているため、CLIと同様にカスタマイズできます。デフォルトのセットアップには3つのワークフロー（Issueトリアージ、PRレビュー、およぼ一般的なメンショントリガーアシスタント）が付属しており、これらは**完全にオープンソースで[編集可能](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=Think%20of%20these%20initial%20workflows,into%20Gemini%20CLI%20GitHub%20Actions)**です。YAMLを調整してAIの動作を調整したり、新しいワークフローを追加したりできます。例えば、Gemini CLIを使用して古い依存関係をスキャンしたり、最近のコード変更に基づいてREADMEを更新したりする夜間ワークフローを作成するなど - 可能性は無限大です。ここでの主な利点は、人間開発者がより難しい問題に集中できるように、日常的または時間のかかるタスクをAIエージェントにオフロードすることです。GitHubのインフラストラクチャ上で実行されるため、介入は必要ありません - まさに「設定して忘れる」AIヘルパーです。

**プロのヒント:** 透明性を確保するために、GitHub ActionsログのActionの出力に注目してください。Gemini CLI Actionログには、実行したプロンプトと、行った（または提案した）変更が表示されます。これは信頼を築くだけでなく、その動作を洗練させるのにも役立ちます。また、チームはActionにエンタープライズグレードの保護手段を組み込んでいます - 例えば、AIがワークフロー内で実行しようとするすべてのシェルコマンドを、[あなた](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=in%20your%20environment%2C%20drastically%20reducing,your%20preferred%20observability%20platform%2C%20like)が許可リスト登録することを要求できます。ですから、シリアスなプロジェクトでも躊躇なく使用してください。そして、Gemini CLIを使用したクールなカスタムワークフローを思いついた場合は、コミュニティへの貢献を検討してください - プロジェクトはリポジトリでの新しいアイデアを歓迎しています！

## ヒント 26: 洞察と可観測性のためにテレメトリを有効にする

**クイックユースケース:** 内蔵の**OpenTelemetry**計測機能をオンにすることで、Gemini CLIの使用状況やパフォーマンスに関する深い洞察を得ます - 使用パターンの分析や[問題](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=,across%20teams%2C%20track%20costs%2C%20ensure)解決のために、AIセッションのメトリクス、ログ、トレースを監視します。

測定と最適化を好む開発者のために、Gemini CLIは内部で何が起きているかを公開する可観測性機能を提供しています。**OpenTelemetry (OTEL)**を活用することで、Gemini CLIは[セッション](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=Built%20on%20OpenTelemetry%20%E2%80%94%20the,Gemini%20CLI%E2%80%99s%20observability%20system%20provides)に関する構造化されたテレメトリデータを出力できます。これには、メトリクス（例：使用トークン数、応答レイテンシ）、アクションのログ、さらにはツール呼び出しのトレースなどが含まれます。テレメトリを有効にすると、次のような質問に答えることができます：*どのカスタムコマンドを最も頻繁に使用しているか？ 今週このプロジェクトでAIが何回ファイルを編集したか？ CLIにテストの実行を依頼したときの平均応答時間は？* このようなデータは、使用パターンや[パフォーマンス](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=,across%20teams%2C%20track%20costs%2C%20ensure)を理解するために非常に貴重です。チームはこれを使用して、開発者がAIアシスタントとどのように対話しているか、ボトルネックがどこにあるかを確認できます。

デフォルトでは、テレメトリは**オフ**です（Geminiはプライバシーとパフォーマンスを尊重します）。`settings.json` で `"telemetry.enabled": true` を設定するか、フラグ [`--telemetry`](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=Setting%20Environment%20Variable%20CLI%20Flag,grpc) を付けてGemini CLIを起動することでオプトインできます。さらに、テレメトリデータの**ターゲット**を選択します：**ローカル**にログ記録することも、Google Cloudのようなバックエンドに送信することもできます。手始めに、`"telemetry.target": "local"` を設定すると良いでしょう - これにより、Geminiは単にローカルファイル（デフォルト）または `["outfile"](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=disable%20telemetry%20,file%20path)` 経由で指定したカスタムパスにテレメトリデータを書き込みます。ローカルテレメトリには、解析したりツールに供給したりできるJSONログが含まれます。より堅牢な監視のためには、`"target": "gcp"`（Google Cloud）を設定するか、Jaegerや[Datadog](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=,between%20backends%20without%20changing%20your)のような他のOpenTelemetry互換システムと統合することも可能です。実際、Gemini CLIのOTELサポートはベンダー中立です - ほぼすべての好みの可観測性スタック（Google Cloud Operations、Prometheus、[など](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=,between%20backends%20without%20changing%20your)）にデータをエクスポートできます。GoogleはCloudへの合理化されたパスを提供しています：GCPを指すと、CLIはプロジェクトのCloud LoggingとCloud Monitoringに直接データを送信でき、そこで通常のダッシュボードやアラート[ツール](https://google-gemini.github.io/gemini-cli/docs/cli/telemetry.html#:~:text=2,explorer%20%2A%20Traces%3A%20https%3A%2F%2Fconsole.cloud.google.com%2Ftraces%2Flist)を使用できます。

どのような洞察が得られるでしょうか？ テレメトリはツール実行、エラー、重要なマイルストーンなどのイベントをキャプチャします。また、プロンプト処理時間や[プロンプト](https://medium.com/google-cloud/gemini-cli-tutorial-series-part-13-gemini-cli-observability-c410806bc112#:~:text=,integrate%20with%20existing%20monitoring%20infrastructure)ごとのトークン数などのメトリクスも記録します。使用状況分析のために、チーム全体で各スラッシュコマンドが何回使用されたか、またはコード生成がどれくらいの頻度で呼び出されたかを集計するかもしれません。パフォーマンス監視のために、応答が遅くなっていないか（APIレート制限やモデルの変更を示唆している可能性があります）を追跡できます。そしてデバッグのために、ツール（例えば `run_shell_command` の失敗）によってスローされたエラーや例外をコンテキスト付きでログに記録されたものを見ることができます。これらすべてのデータは、Google CloudのMonitoringなどのプラットフォームに送信すれば視覚化できます - 例えば、「1日あたりの使用トークン数」や「ツールXのエラー率」のダッシュボードを作成できます。これにより、本質的にAIの「脳」とあなたの使用状況を覗く窓が得られます。これは、すべてが[スムーズ](https://medium.com/google-cloud/gemini-cli-tutorial-series-part-13-gemini-cli-observability-c410806bc112#:~:text=resource%20utilization%20%2A%20%20Real,integrate%20with%20existing%20monitoring%20infrastructure)に実行されていることを確認するために企業設定では特に役立ちます。

テレメトリを有効にすると多少のオーバーヘッド（追加のデータ処理）が発生するため、個人使用では常に100%オンにしておく必要はないかもしれません。しかし、デバッグセッションや断続的なヘルスチェックには素晴らしいです。1つのアプローチは、CIサーバーやチームの共有環境で有効にして統計を収集し、ローカルでは必要なとき以外オフにしておくことです。いつでもその場で切り替えられることを覚えておいてください：設定を更新し、必要に応じて `/memory refresh` でリロードするか、`--telemetry` フラグでGemini CLIを再起動します。また、すべてのテレメトリはあなたの管理下にあります - エンドポイントと資格情報の環境変数を尊重するため、データは意図した場所にのみ送信されます。この機能はGemini CLIをブラックボックスから観測所に変え、AIエージェントがあなたの世界とどのように相互作用しているかに光を当てるため、その相互作用を継続的に改善できます。

**プロのヒント:** 現在のセッションの統計を素早く見たいだけなら（完全なテレメトリなしで）、`/stats` コマンドを使用してください。トークン使用量やセッションの長さなどのメトリクスを[CLI](https://www.howtouselinux.com/post/the-complete-google-gemini-cli-cheat-sheet-and-guide#:~:text=Command%20Description%20,tag%3E%60Save%20the%20current%20conversation)に直接出力します。これは即時の数値を確認するための軽量な方法です。しかし、長期的またはマルチセッションの分析には、テレメトリが進むべき道です。そして、クラウドリジェクトにテレメトリを送信している場合は、ダッシュボードやアラート（例：エラー率が急増したり、トークン使用量がしきい値に達したりした場合のアラート）の設定を検討してください - これにより、チームでのGemini CLIの使用方法における問題を積極的にキャッチできます。

## ヒント 27: ロードマップに注目する（バックグラウンドエージェントなど）

**クイックユースケース:** 今後のGemini CLI機能に関する情報を入手してください - 公開されている**Gemini CLIロードマップ**をフォローすることで、[到着](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=quality.%20,related%20to%20security%20and%20privacy)する前に主要な計画された拡張機能（*長時間実行タスクのためのバックグラウンドエージェント*など）を知ることができ、計画を立てたりフィードバックを提供したりできます。

Gemini CLIは急速に進化しており、新しいリリースが頻繁に出ているため、何が控えているかを追跡するのが賢明です。GoogleはGitHub上でGemini CLIの**公開ロードマップ**を維持しており、近い[将来](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=This%20document%20outlines%20our%20approach,live%20in%20our%20GitHub%20Issues)に向けた主要な重点分野と機能を詳述しています。これは基本的に（一連のIssueでもある）生きたドキュメントであり、開発者が何に取り組んでいるか、パイプラインに何があるかを確認できます。例えば、ロードマップ上のエキサイティングな項目の1つは、**バックグラウンドエージェント**のサポートです - バックグラウンドで実行してタスクを継続的または[非同期的](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=quality.%20,related%20to%20security%20and%20privacy)に処理する自律エージェントを生成する機能です。ロードマップの議論によると、これらのバックグラウンドエージェントを使用すると、インタラクティブセッションを拘束することなく、長時間実行されるプロセスをGemini CLIに委任できるようになります。例えば、プロジェクトの特定のイベントを監視するバックグラウンドエージェントを開始したり、ローカルマシン上またはCloud [Run](https://github.com/google-gemini/gemini-cli/issues/4168#:~:text=How%20will%20it%20work%3F)のようなサービスにデプロイして定期的にタスクを実行したりできます。この機能は、[CLI](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=quality.%20,related%20to%20security%20and%20privacy)から直接「長時間実行される自律タスクとプロアクティブな支援を可能にする」ことを目的としており、本質的にGemini CLIの有用性を単なるオンデマンドクエリ以上に拡張します。

ロードマップをチェックすることで、他の計画された機能についても知ることができます。これらには、新しいツール統合、追加のGeminiモデルバージョンのサポート、UI/UXの改善などが含まれる可能性があります。ロードマップは通常、「エリア」（例えば *拡張性*、*モデル*、*バックグラウンド*など）ごとに整理されており、マイルストーン（[配信](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=Our%20roadmap%20is%20managed%20directly,more%20detailed%20list%20of%20tasks)の目標四半期のようなもの）でタグ付けされることがよくあります。いつ何かがランディングするという保証ではありませんが、チームの優先順位がよくわかります。プロジェクトはオープンソースなので、ロードマップ項目のリンクされたGitHub Issueに飛び込んで、設計提案や進捗状況を確認することさえできます。Gemini CLIに依存している開発者にとって、この透明性は変更を予測できることを意味します - 必要な機能を追加するAPIかもしれず、準備したい破壊的変更が来るかもしれません。

ロードマップをフォローすることは、GitHubプロジェクトボードや「Roadmap」というラベルの付いたIssueをブックマークして定期的にチェックするだけのことです。いくつかの主要なアップデート（拡張機能の導入やIDE統合など）は、公式に発表される前にロードマップでほのめかされていたため、先取りできます。さらに、Gemini CLIチームは、それらの将来の機能に関するコミュニティフィードバックを奨励することがよくあります。バックグラウンドエージェントのようなもののアイデアやユースケースがある場合は、通常、Issueやディスカッションスレッドにコメントして開発に影響を与えることができます。

**プロのヒント:** Gemini CLIはオープンソース（Apache 2.0ライセンス）なので、ロードマップを見るだけでなく、参加することもできます！ メンテナーは、特に[ロードマップ](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=As%20an%20Apache%202,opening%20an%20issue%20for%20discussion)に沿った項目への貢献を歓迎しています。本当に気にかけている機能がある場合は、コードを提供したり、プレビュー段階になったらテストしたりすることを検討してください。少なくとも、必要なものがまだロードマップにない場合は、機能リクエストを開くことが[できます](https://google-gemini.github.io/gemini-cli/ROADMAP.html#:~:text=As%20an%20Apache%202,opening%20an%20issue%20for%20discussion)。ロードマップページ自体に、変更を提案する方法に関するガイダンスがあります。プロジェクトに関わることは、最新情報を入手し続けるだけでなく、使用するツールを形作ることにもなります。結局のところ、Gemini CLIはコミュニティの関与を念頭に置いて構築されており、最近の多くの機能（特定の拡張機能やツールなど）はコミュニティの提案から始まりました。

## ヒント 28: `Extensions` でGemini CLIを拡張する

**クイックユースケース:** プラグアンドプレイの**拡張機能**をインストールしてGemini CLIに新しい機能を追加します - 例えば、お気に入りのデータベースやクラウドサービスと統合し、あなたに大きな負担をかけることなくAIのツールセットを[拡張](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=Gemini%20CLI%20is%20an%20open,design%20platforms%20to%20payment%20services)します。CLIに新しいトリックを教えるためにアプリをインストールするようなものです。

拡張機能は2025年後半に導入されたゲームチェンジャーです：これらはGemini CLIの機能をモジュラーな[方法](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=Gemini%20CLI%20is%20an%20open,design%20platforms%20to%20payment%20services)で**カスタマイズおよび拡張**することを可能にします。拡張機能は基本的に、Gemini CLIを外部ツールやサービスに接続する設定（およびオプションでコード）のバンドルです。例えば、GoogleはGoogle Cloud用の一連の拡張機能をリリースしました - Cloud Runへのアプリデプロイを支援するもの、BigQuery管理用、アプリケーションセキュリティ分析用[など](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=In%20just%20three%20months%20since,source%20community)です。パートナーやコミュニティ開発者は、あらゆる種類の拡張機能を構築しています：Dynatrace（モニタリング）、Elastic（検索分析）、Figma（デザインアセット）、Shopify、Snyk（セキュリティスキャン）、Stripe（支払い）など、リストは[増え続けています](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=In%20just%20three%20months%20since,source%20community)。適切な拡張機能をインストールすることで、Gemini CLIに新しいドメイン固有のツールを使用する能力を即座に付与できます。素晴らしいのは、これらの拡張機能には、新しいツールを[効果的に](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=Gemini%20CLI%20is%20an%20open,design%20platforms%20to%20payment%20services)使用する方法をAIに教える事前定義された**「プレイブック」**が付属していることです。つまり、インストールしたら、Gemini CLIにそれらのサービスを使用したタスクを実行するように依頼でき、AIはその知識が組み込まれているかのように、呼び出すべき適切なAPIやコマンドを知っています。

拡張機能の使用は非常に簡単です。CLIにはそれらを管理するコマンドがあります：`gemini extensions install <URL>`。通常、拡張機能のGitHubリポジトリのURLまたはローカルパスを指定すると、CLIがそれをフェッチしてインストール[します](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=It%E2%80%99s%20easy%20to%20install%20an,%E2%80%9D%20from%20your%20command%20line)。例えば、公式拡張機能をインストールするには、`gemini extensions install https://github.com/google-gemini/gemini-cli-extension-cloud-run` を実行します。数秒以内に、拡張機能が環境に追加されます（`~/.gemini/extensions/` またはプロジェクトの `.gemini/extensions/` フォルダに保存されます）。その後、CLIで `/extensions` を実行してアクティブな[拡張機能](https://google-gemini.github.io/gemini-cli/docs/cli/commands.html#:~:text=,See%20Gemini%20CLI%20Extensions)を一覧表示できます。その時点から、AIは新しいツールを自由に使えます。Cloud Run拡張機能であれば、「私のアプリをCloud Runにデプロイして」と言うことができ、Gemini CLIは実際にそれを実行できます（拡張機能のツールを通じて基礎となる `gcloud` コマンドを呼び出すことによって）。基本的に、拡張機能はGemini CLIの機能のファーストクラスの拡張として機能しますが、必要なものだけをオプトインします。

拡張機能の周りには**オープンなエコシステム**があります。Googleは利用可能な[拡張機能](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=Access%20an%20open%2C%20growing%20ecosystem,of%20partners%20and%20builders)をリストした公式の拡張機能ページを持っており、フレームワークがオープンであるため、誰でも独自のものを作成して共有できます。特定の内部APIやワークフローがある場合は、Gemini CLIがそれを支援できるように独自の拡張機能を構築できます。拡張機能の作成は思ったより簡単です：通常、[追加](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Extensions)するツールやコンテキストを記述した `gemini-extension.json` ファイルを含むディレクトリ（例えば `my-extension/`）を作成します。新しいスラッシュコマンドを定義したり、AIが呼び出すことができるリモートAPIを指定したりするかもしれません。Gemini CLIのコアを変更する必要はありません - 拡張機能をドロップインするだけです。CLIはこれらを実行時にロードするように設計されています。多くの拡張機能は、AIが使用できるカスタム *MCPツール*（Model Context Protocolサーバーまたは関数）の追加で構成されています。例えば、外部翻訳APIにフックして `/translate` コマンドを追加する拡張機能があります；インストールされると、AIは `/translate` の使い方を知ります。主な利点は**モジュラリティ**です：必要な拡張機能だけをインストールしてCLIを軽量に保ちつつ、実質的にあらゆるものを統合するオプションがあります。

拡張機能を管理するには、`install` コマンド以外に、同様のCLIコマンド（`gemini extensions update` または単にフォルダを削除すること）で更新または削除できます。使用している拡張機能の更新を時々チェックすることをお勧めします。CLIは将来的に「拡張機能マーケットプレイス」スタイルのインターフェースを導入するかもしれませんが、今のところはGitHubリポジトリや公式カタログを探索することが新しいものを見つける方法です。ローンチ時に人気のあるものには、GenAI **Genkit** 拡張機能（生成AIアプリ構築用）や、CI/CD、データベース管理などをカバーするさまざまなGoogle Cloud拡張機能が含まれます。

**プロのヒント:** 独自の拡張機能を構築している場合は、既存のものを例として見ることから始めてください。公式ドキュメントには、スキーマと[機能](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Extensions)を含む**拡張機能ガイド**が用意されています。プライベートな拡張機能を作成する簡単な方法は、`GEMINI.md` の `@include` 機能を使用してスクリプトやコンテキストを注入することですが、完全な拡張機能はより多くの力（ツールパッケージなど）を提供します。また、拡張機能にはコンテキストファイルを含めることができるため、ドメイン知識をプリロードするために使用できます。会社の内部API用の拡張機能で、APIの概要とそれを呼び出すツールを含んでいると想像してください - AIはそのAPIに関連するリクエストの処理方法を知ることになります。要するに、拡張機能はGemini CLIがあらゆるものとインターフェースできる新しい世界を開きます。新しい追加のために拡張機能マーケットプレイスに注目し、作成した便利な拡張機能をコミュニティと共有することを躊躇しないでください - 何千もの他の[開発者](https://blog.google/technology/developers/gemini-cli-extensions/#:~:text=Gemini%20CLI%20extensions%20are%20here,and%20build%20your%20own%20extension)を助けることになるかもしれません。

## ヒント 29: コーギーモードのイースターエッグ 🐕

最後に、生産性のヒントではありませんが、楽しいイースターエッグです - Gemini CLIで `*/corgi*` コマンドを試してみてください。これにより、[ターミナル](https://medium.com/@ferreradaniel/gemini-cli-free-ai-tool-upgrade-5-new-features-you-need-right-now-04cfefac5e93#:~:text=Easter%20Egg%3A%20Corgi%20Mode%20in,Gemini%20CLI)をかわいいコーギーのアニメーションが走り回る **「コーギーモード」** が切り替わります！ コーディングが上手くなるわけではありませんが、長いコーディングセッション中に気分を明るくしてくれることは間違いありません。CLIインターフェースの中を疾走するアスキーアートのコーギーが表示されます。オフにするには、もう一度 `/corgi` を実行します。

これはチームが追加した純粋に楽しみのための機能です（そしてはい、コーギーモードに開発時間を費やすことについての皮肉な[議論](https://github.com/google-gemini/gemini-cli/issues/5674#:~:text=How%20about%20you%20NOT%20implement,this%20needed%3F%20Because%20people)さえあります）。作成者がツールにいくつかの遊び心を隠していることを示しています。ですから、ちょっとした休憩や笑顔が必要なときは、`/corgi` を試してみてください。🐕🎉

*（噂によると、他にもイースターエッグやモードがあるかもしれません - 誰にもわかりませんが？ おそらく "/partyparrot" や同様のもの。チートシートやヘルプコマンドには `/corgi` が記載されているので、秘密というわけではなく、あまり使われていないだけです。これであなたもジョークの仲間入りです！）*

---

**結論:**

Gemini CLIのプロのヒントと機能の包括的なリストをカバーしました。`GEMINI.md` による持続的コンテキストの設定から、カスタムコマンドの作成、MCPサーバーのような高度なツールの使用、マルチモーダル入力の活用、ワークフローの自動化まで、このAIコマンドラインアシスタントができることはたくさんあります。外部開発者として、Gemini CLIを日常のルーチンに統合できます - それは、退屈なタスクを処理し、洞察を提供し、環境のトラブルシューティングさえできる、ターミナル内の強力な味方のようなものです。

Gemini CLIは急速に進化しており（コミュニティの貢献があるオープンソースであるため）、新しい機能や改善が常に地平線上にあります。このガイドのプロのヒントをマスターすることで、このツールの可能性を最大限に活用するのに有利な立場になります。単にAIモデルを使用することについてではなく、ソフトウェアを開発および管理する方法にAIを深く統合することについてです。

Gemini CLIでのハッピーコーディングを、そして「ターミナルのAIエージェント」があなたをどこまで連れて行ってくれるかを探求することを楽しんでください。

**あなたは今、指先にAIのスイスアーミーナイフを持っています - 賢く使えば、より生産的な（そしておそらくより幸せな）開発者になれるでしょう**！
